From 87daf5fd8a8336d70b44a9d97772efa880036f0c Mon Sep 17 00:00:00 2001
Message-ID: <87daf5fd8a8336d70b44a9d97772efa880036f0c.1740050334.git.lorenzo@kernel.org>
From: Lorenzo Bianconi <lorenzo@kernel.org>
Date: Thu, 20 Feb 2025 12:18:51 +0100
Subject: [PATCH net-next] net: airoha: take into account all possible GDM
 combinations in airhoa_is_lan_gdm_port()

Signed-off-by: Lorenzo Bianconi <lorenzo@kernel.org>
---
 drivers/net/ethernet/airoha/airoha_eth.c | 35 ++++++++++++++++++------
 1 file changed, 26 insertions(+), 9 deletions(-)

--- a/drivers/net/ethernet/airoha/airoha_eth.h
+++ b/drivers/net/ethernet/airoha/airoha_eth.h
@@ -621,13 +621,26 @@ u32 airoha_rmw(void __iomem *base, u32 o
 #define airoha_qdma_clear(qdma, offset, val)			\
 	airoha_rmw((qdma)->regs, (offset), (val), 0)
 
-static inline bool airhoa_is_lan_gdm_port(struct airoha_gdm_port *port)
+static inline bool airhoa_is_lan_gdm_port(struct airoha_eth *eth,
+				   struct airoha_gdm_port *port)
 {
 	/* GDM1 port on EN7581 SoC is connected to the lan dsa switch.
 	 * GDM{2,3,4} can be used as wan port connected to an external
 	 * phy module.
 	 */
-	return port->id == 1;
+
+	/* GDM2 is always used as WAN port */
+	if (port->id == 2)
+		return false;
+
+	if (eth->ports[1])
+		return true;
+
+	/* GDM1 is always used as LAN port */
+	if (port->id == 1)
+		return true;
+
+	return !eth->ports[0];
 }
 
 static inline bool airoha_is_7581(struct airoha_eth *eth)
--- a/drivers/net/ethernet/airoha/airoha_eth.c
+++ b/drivers/net/ethernet/airoha/airoha_eth.c
@@ -83,8 +83,8 @@ static void airoha_set_macaddr(struct ai
 	struct airoha_eth *eth = port->qdma->eth;
 	u32 val, reg;
 
-	reg = airhoa_is_lan_gdm_port(port) ? REG_FE_LAN_MAC_H
-					   : REG_FE_WAN_MAC_H;
+	reg = airhoa_is_lan_gdm_port(eth, port) ? REG_FE_LAN_MAC_H
+						: REG_FE_WAN_MAC_H;
 	val = (addr[0] << 16) | (addr[1] << 8) | addr[2];
 	airoha_fe_wr(eth, reg, val);
 
@@ -3294,11 +3294,10 @@ static int airoha_register_port_debugfs(
 }
 
 static int airoha_alloc_gdm_port(struct airoha_eth *eth,
-				 struct device_node *np, int index)
+				 struct device_node *np)
 {
 	const __be32 *id_ptr = of_get_property(np, "reg", NULL);
 	struct airoha_gdm_port *port;
-	struct airoha_qdma *qdma;
 	struct net_device *dev;
 	int err, p;
 	u32 id;
@@ -3329,7 +3328,6 @@ static int airoha_alloc_gdm_port(struct
 		return -ENOMEM;
 	}
 
-	qdma = &eth->qdma[index % AIROHA_MAX_NUM_QDMA];
 	dev->netdev_ops = &airoha_netdev_ops;
 	dev->ethtool_ops = &airoha_ethtool_ops;
 	dev->max_mtu = AIROHA_MAX_MTU;
@@ -3338,7 +3336,6 @@ static int airoha_alloc_gdm_port(struct
 	dev->features |= AIROHA_HW_FEATURES;
 	dev->vlan_features = AIROHA_HW_FEATURES;
 	dev->dev.of_node = np;
-	dev->irq = qdma->irq_banks[0].irq;
 	SET_NETDEV_DEV(dev, eth->dev);
 
 	/* reserve hw queues for HTB offloading */
@@ -3359,35 +3356,47 @@ static int airoha_alloc_gdm_port(struct
 	port = netdev_priv(dev);
 	u64_stats_init(&port->stats.syncp);
 	spin_lock_init(&port->stats.lock);
-	port->qdma = qdma;
 	port->dev = dev;
 	port->id = id;
 	port->np = np;
 	eth->ports[p] = port;
 
-	err = airoha_metadata_dst_alloc(port);
-	if (err)
-		return err;
+	return airoha_metadata_dst_alloc(port);
+}
 
-	if (airhoa_is_phy_external(port)) {
-		err = airoha_setup_phylink(dev);
+static int airoha_register_gdm_ports(struct airoha_eth *eth)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(eth->ports); i++) {
+		struct airoha_gdm_port *port = eth->ports[i];
+		struct airoha_qdma *qdma;
+		int err, qdma_idx;
+
+		if (!port)
+			continue;
+
+		qdma_idx = airhoa_is_lan_gdm_port(eth, port) ? 0 : 1;
+		qdma = &eth->qdma[qdma_idx];
+		port->dev->irq = qdma->irq_banks[0].irq;
+		port->qdma = qdma;
+
+		err = airoha_register_port_debugfs(port);
 		if (err)
-			goto free_metadata_dst;
-	}
+			return err;
 
-	err = airoha_register_port_debugfs(port);
-	if (err)
-		goto free_metadata_dst;
+		if (airhoa_is_phy_external(port)) {
+			err = airoha_setup_phylink(port->dev);
+			if (err)
+				return err;
+		}
 
-	err = register_netdev(dev);
-	if (err)
-		goto free_metadata_dst;
+		err = register_netdev(port->dev);
+		if (err)
+			return err;
+	}
 
 	return 0;
-
-free_metadata_dst:
-	airoha_metadata_dst_free(port);
-	return err;
 }
 
 static int airoha_probe(struct platform_device *pdev)
@@ -3464,7 +3473,6 @@ static int airoha_probe(struct platform_
 	for (i = 0; i < ARRAY_SIZE(eth->qdma); i++)
 		airoha_qdma_start_napi(&eth->qdma[i]);
 
-	i = 0;
 	for_each_child_of_node(pdev->dev.of_node, np) {
 		if (!of_device_is_compatible(np, "airoha,eth-mac"))
 			continue;
@@ -3472,13 +3480,17 @@ static int airoha_probe(struct platform_
 		if (!of_device_is_available(np))
 			continue;
 
-		err = airoha_alloc_gdm_port(eth, np, i++);
+		err = airoha_alloc_gdm_port(eth, np);
 		if (err) {
 			of_node_put(np);
 			goto error_napi_stop;
 		}
 	}
 
+	err = airoha_register_gdm_ports(eth);
+	if (err)
+		goto error_napi_stop;
+
 	return 0;
 
 error_napi_stop:
@@ -3492,14 +3504,17 @@ error_hw_cleanup:
 	for (i = 0; i < ARRAY_SIZE(eth->ports); i++) {
 		struct airoha_gdm_port *port = eth->ports[i];
 
-		if (port && port->dev->reg_state == NETREG_REGISTERED) {
+		if (!port)
+			continue;
+
+		if (port->dev->reg_state == NETREG_REGISTERED) {
 			unregister_netdev(port->dev);
-			airoha_metadata_dst_free(port);
 			if (airhoa_is_phy_external(port)) {
 				phylink_destroy(port->phylink);
 				airoha_pcs_destroy(port->pcs);
 			}
 		}
+		airoha_metadata_dst_free(port);
 	}
 	free_netdev(eth->napi_dev);
 	platform_set_drvdata(pdev, NULL);
--- a/drivers/net/ethernet/airoha/airoha_ppe.c
+++ b/drivers/net/ethernet/airoha/airoha_ppe.c
@@ -316,7 +316,7 @@ static int airoha_ppe_foe_entry_prepare(
 			if (!airoha_is_valid_gdm_port(eth, port))
 				return -EINVAL;
 
-			if (dsa_port >= 0)
+			if (dsa_port >= 0 || eth->ports[1])
 				pse_port = port->id == 4 ? FE_PSE_PORT_GDM4
 							 : port->id;
 			else
@@ -337,7 +337,7 @@ static int airoha_ppe_foe_entry_prepare(
 			/* For downlink traffic consume SRAM memory for hw
 			 * forwarding descriptors queue.
 			 */
-			if (airhoa_is_lan_gdm_port(port))
+			if (airhoa_is_lan_gdm_port(eth, port))
 				val |= AIROHA_FOE_IB2_FAST_PATH;
 			if (dsa_port >= 0)
 				val |= FIELD_PREP(AIROHA_FOE_IB2_NBQ,
