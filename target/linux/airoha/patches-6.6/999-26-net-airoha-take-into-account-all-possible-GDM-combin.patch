From 87daf5fd8a8336d70b44a9d97772efa880036f0c Mon Sep 17 00:00:00 2001
Message-ID: <87daf5fd8a8336d70b44a9d97772efa880036f0c.1740050334.git.lorenzo@kernel.org>
From: Lorenzo Bianconi <lorenzo@kernel.org>
Date: Thu, 20 Feb 2025 12:18:51 +0100
Subject: [PATCH net-next] net: airoha: take into account all possible GDM
 combinations in airhoa_is_lan_gdm_port()

Signed-off-by: Lorenzo Bianconi <lorenzo@kernel.org>
---
 drivers/net/ethernet/airoha/airoha_eth.c | 35 ++++++++++++++++++------
 1 file changed, 26 insertions(+), 9 deletions(-)

--- a/drivers/net/ethernet/airoha/airoha_eth.c
+++ b/drivers/net/ethernet/airoha/airoha_eth.c
@@ -67,13 +67,26 @@ static void airoha_qdma_irq_disable(stru
 	airoha_qdma_set_irqmask(qdma, index, mask, 0);
 }
 
-static bool airhoa_is_lan_gdm_port(struct airoha_gdm_port *port)
+static bool airhoa_is_lan_gdm_port(struct airoha_eth *eth,
+				   struct airoha_gdm_port *port)
 {
 	/* GDM1 port on EN7581 SoC is connected to the lan dsa switch.
 	 * GDM{2,3,4} can be used as wan port connected to an external
 	 * phy module.
 	 */
-	return port->id == 1;
+
+	/* GDM2 is always used as WAN port */
+	if (port->id == 2)
+		return false;
+
+	if (eth->ports[1])
+		return true;
+
+	/* GDM1 is always used as LAN port */
+	if (port->id == 1)
+		return true;
+
+	return !eth->ports[0];
 }
 
 static void airoha_set_macaddr(struct airoha_gdm_port *port, const u8 *addr)
@@ -81,8 +94,8 @@ static void airoha_set_macaddr(struct ai
 	struct airoha_eth *eth = port->qdma->eth;
 	u32 val, reg;
 
-	reg = airhoa_is_lan_gdm_port(port) ? REG_FE_LAN_MAC_H
-					   : REG_FE_WAN_MAC_H;
+	reg = airhoa_is_lan_gdm_port(eth, port) ? REG_FE_LAN_MAC_H
+						: REG_FE_WAN_MAC_H;
 	val = (addr[0] << 16) | (addr[1] << 8) | addr[2];
 	airoha_fe_wr(eth, reg, val);
 
@@ -2589,11 +2602,10 @@ static int airoha_register_port_debugfs(
 }
 
 static int airoha_alloc_gdm_port(struct airoha_eth *eth,
-				 struct device_node *np, int index)
+				 struct device_node *np)
 {
 	const __be32 *id_ptr = of_get_property(np, "reg", NULL);
 	struct airoha_gdm_port *port;
-	struct airoha_qdma *qdma;
 	struct net_device *dev;
 	int err, p;
 	u32 id;
@@ -2624,7 +2636,6 @@ static int airoha_alloc_gdm_port(struct
 		return -ENOMEM;
 	}
 
-	qdma = &eth->qdma[index % AIROHA_MAX_NUM_QDMA];
 	dev->netdev_ops = &airoha_netdev_ops;
 	dev->ethtool_ops = &airoha_ethtool_ops;
 	dev->max_mtu = AIROHA_MAX_MTU;
@@ -2636,7 +2647,6 @@ static int airoha_alloc_gdm_port(struct
 	dev->features |= dev->hw_features;
 	dev->vlan_features = dev->hw_features;
 	dev->dev.of_node = np;
-	dev->irq = qdma->irq;
 	SET_NETDEV_DEV(dev, eth->dev);
 
 	/* reserve hw queues for HTB offloading */
@@ -2667,26 +2677,46 @@ static int airoha_alloc_gdm_port(struct
 	port = netdev_priv(dev);
 	u64_stats_init(&port->stats.syncp);
 	spin_lock_init(&port->stats.lock);
-	port->qdma = qdma;
 	port->dev = dev;
 	port->id = id;
 	eth->ports[p] = port;
 
-	err = airoha_metadata_dst_alloc(port);
-	if (err)
-		return err;
-
-	if (airhoa_is_phy_external(port)) {
-		err = airoha_setup_phylink(dev);
-		if (err)
-			return err;
-	}
+	return airoha_metadata_dst_alloc(port);
+}
 
-	err = airoha_register_port_debugfs(port);
-	if (err)
-		return err;
+static int airoha_register_gdm_ports(struct airoha_eth *eth)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(eth->ports); i++) {
+		struct airoha_gdm_port *port = eth->ports[i];
+		struct airoha_qdma *qdma;
+		int err, qdma_idx;
+
+		if (!port)
+			continue;
 
-	return register_netdev(dev);
+		qdma_idx = airhoa_is_lan_gdm_port(eth, port) ? 0 : 1;
+		qdma = &eth->qdma[qdma_idx];
+		port->dev->irq = qdma->irq;
+		port->qdma = qdma;
+
+		err = airoha_register_port_debugfs(port);
+		if (err)
+			return err;
+
+		if (airhoa_is_phy_external(port)) {
+			err = airoha_setup_phylink(port->dev);
+			if (err)
+				return err;
+		}
+
+		err = register_netdev(port->dev);
+		if (err)
+			return err;
+	}
+
+	return 0;
 }
 
 static int airoha_probe(struct platform_device *pdev)
@@ -2737,7 +2767,6 @@ static int airoha_probe(struct platform_
 	for (i = 0; i < ARRAY_SIZE(eth->qdma); i++)
 		airoha_qdma_start_napi(&eth->qdma[i]);
 
-	i = 0;
 	for_each_child_of_node(pdev->dev.of_node, np) {
 		if (!of_device_is_compatible(np, "airoha,eth-mac"))
 			continue;
@@ -2745,13 +2774,17 @@ static int airoha_probe(struct platform_
 		if (!of_device_is_available(np))
 			continue;
 
-		err = airoha_alloc_gdm_port(eth, np, i++);
+		err = airoha_alloc_gdm_port(eth, np);
 		if (err) {
 			of_node_put(np);
 			goto error_napi_stop;
 		}
 	}
 
+	err = airoha_register_gdm_ports(eth);
+	if (err)
+		goto error_napi_stop;
+
 	return 0;
 
 error_napi_stop:
@@ -2765,14 +2780,17 @@ error_hw_cleanup:
 	for (i = 0; i < ARRAY_SIZE(eth->ports); i++) {
 		struct airoha_gdm_port *port = eth->ports[i];
 
-		if (port && port->dev->reg_state == NETREG_REGISTERED) {
+		if (!port)
+			continue;
+
+		if (port->dev->reg_state == NETREG_REGISTERED) {
 			unregister_netdev(port->dev);
-			airoha_metadata_dst_free(port);
 			if (airhoa_is_phy_external(port)) {
 				phylink_destroy(port->phylink);
 				airoha_pcs_destroy(port->pcs);
 			}
 		}
+		airoha_metadata_dst_free(port);
 	}
 	free_netdev(eth->napi_dev);
 	platform_set_drvdata(pdev, NULL);
--- a/drivers/net/ethernet/airoha/airoha_ppe.c
+++ b/drivers/net/ethernet/airoha/airoha_ppe.c
@@ -197,7 +197,8 @@ static int airoha_get_dsa_port(struct ne
 #endif
 }
 
-static int airoha_ppe_foe_entry_prepare(struct airoha_foe_entry *hwe,
+static int airoha_ppe_foe_entry_prepare(struct airoha_eth *eth,
+					struct airoha_foe_entry *hwe,
 					struct net_device *dev, int type,
 					struct airoha_flow_data *data,
 					int l4proto, u32 priority)
@@ -225,7 +226,7 @@ static int airoha_ppe_foe_entry_prepare(
 		struct airoha_gdm_port *port = netdev_priv(dev);
 		u8 pse_port;
 
-		if (dsa_port >= 0)
+		if (dsa_port >= 0 || eth->ports[1])
 			pse_port = port->id == 4 ? FE_PSE_PORT_GDM4 : port->id;
 		else
 			/* uplink relies on GDM2 loopback for GDM3 and GDM4 */
@@ -662,7 +663,7 @@ static int airoha_ppe_flow_offload_repla
 	    !is_valid_ether_addr(data.eth.h_dest))
 		return -EINVAL;
 
-	err = airoha_ppe_foe_entry_prepare(&hwe, odev, offload_type,
+	err = airoha_ppe_foe_entry_prepare(eth, &hwe, odev, offload_type,
 					   &data, l4proto, priority);
 	if (err)
 		return err;
