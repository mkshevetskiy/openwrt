From 87daf5fd8a8336d70b44a9d97772efa880036f0c Mon Sep 17 00:00:00 2001
Message-ID: <87daf5fd8a8336d70b44a9d97772efa880036f0c.1740050334.git.lorenzo@kernel.org>
From: Lorenzo Bianconi <lorenzo@kernel.org>
Date: Thu, 20 Feb 2025 12:18:51 +0100
Subject: [PATCH net-next] net: airoha: take into account all possible GDM
 combinations in airhoa_is_lan_gdm_port()

Signed-off-by: Lorenzo Bianconi <lorenzo@kernel.org>
---
 drivers/net/ethernet/airoha/airoha_eth.c | 35 ++++++++++++++++++------
 1 file changed, 26 insertions(+), 9 deletions(-)

--- a/drivers/net/ethernet/airoha/airoha_eth.h
+++ b/drivers/net/ethernet/airoha/airoha_eth.h
@@ -621,13 +621,26 @@ u32 airoha_rmw(void __iomem *base, u32 o
 #define airoha_qdma_clear(qdma, offset, val)			\
 	airoha_rmw((qdma)->regs, (offset), (val), 0)
 
-static inline bool airhoa_is_lan_gdm_port(struct airoha_gdm_port *port)
+static inline bool airhoa_is_lan_gdm_port(struct airoha_eth *eth,
+				   struct airoha_gdm_port *port)
 {
 	/* GDM1 port on EN7581 SoC is connected to the lan dsa switch.
 	 * GDM{2,3,4} can be used as wan port connected to an external
 	 * phy module.
 	 */
-	return port->id == 1;
+
+	/* GDM2 is always used as WAN port */
+	if (port->id == 2)
+		return false;
+
+	if (eth->ports[1])
+		return true;
+
+	/* GDM1 is always used as LAN port */
+	if (port->id == 1)
+		return true;
+
+	return !eth->ports[0];
 }
 
 static inline bool airoha_is_7581(struct airoha_eth *eth)
--- a/drivers/net/ethernet/airoha/airoha_eth.c
+++ b/drivers/net/ethernet/airoha/airoha_eth.c
@@ -83,8 +83,8 @@ static void airoha_set_macaddr(struct ai
 	struct airoha_eth *eth = port->qdma->eth;
 	u32 val, reg;
 
-	reg = airhoa_is_lan_gdm_port(port) ? REG_FE_LAN_MAC_H
-					   : REG_FE_WAN_MAC_H;
+	reg = airhoa_is_lan_gdm_port(eth, port) ? REG_FE_LAN_MAC_H
+						: REG_FE_WAN_MAC_H;
 	val = (addr[0] << 16) | (addr[1] << 8) | addr[2];
 	airoha_fe_wr(eth, reg, val);
 
@@ -3286,11 +3286,10 @@ static int airoha_register_port_debugfs(
 }
 
 static int airoha_alloc_gdm_port(struct airoha_eth *eth,
-				 struct device_node *np, int index)
+				 struct device_node *np)
 {
 	const __be32 *id_ptr = of_get_property(np, "reg", NULL);
 	struct airoha_gdm_port *port;
-	struct airoha_qdma *qdma;
 	struct net_device *dev;
 	int err, p;
 	u32 id;
@@ -3321,7 +3320,6 @@ static int airoha_alloc_gdm_port(struct
 		return -ENOMEM;
 	}
 
-	qdma = &eth->qdma[index % AIROHA_MAX_NUM_QDMA];
 	dev->netdev_ops = &airoha_netdev_ops;
 	dev->ethtool_ops = &airoha_ethtool_ops;
 	dev->max_mtu = AIROHA_MAX_MTU;
@@ -3330,7 +3328,6 @@ static int airoha_alloc_gdm_port(struct
 	dev->features |= AIROHA_HW_FEATURES;
 	dev->vlan_features = AIROHA_HW_FEATURES;
 	dev->dev.of_node = np;
-	dev->irq = qdma->irq_banks[0].irq;
 	SET_NETDEV_DEV(dev, eth->dev);
 
 	/* reserve hw queues for HTB offloading */
@@ -3351,7 +3348,6 @@ static int airoha_alloc_gdm_port(struct
 	port = netdev_priv(dev);
 	u64_stats_init(&port->stats.syncp);
 	spin_lock_init(&port->stats.lock);
-	port->qdma = qdma;
 	port->dev = dev;
 	port->id = id;
 	port->np = np;
@@ -3351,11 +3348,17 @@ static int airoha_alloc_gdm_port(struct
 
 	for (i = 0; i < ARRAY_SIZE(eth->ports); i++) {
 		struct airoha_gdm_port *port = eth->ports[i];
-		int err;
+		struct airoha_qdma *qdma;
+		int err, qdma_idx;
 
 		if (!port)
 			continue;
 
+		qdma_idx = airhoa_is_lan_gdm_port(eth, port) ? 0 : 1;
+		qdma = &eth->qdma[qdma_idx];
+		port->dev->irq = qdma->irq_banks[0].irq;
+		port->qdma = qdma;
+
 		err = airoha_register_port_debugfs(port);
 		if (err)
 			return err;
@@ -3456,7 +3465,6 @@ static int airoha_probe(struct platform_
 	for (i = 0; i < ARRAY_SIZE(eth->qdma); i++)
 		airoha_qdma_start_napi(&eth->qdma[i]);
 
-	i = 0;
 	for_each_child_of_node(pdev->dev.of_node, np) {
 		if (!of_device_is_compatible(np, "airoha,eth-mac"))
 			continue;
@@ -3464,7 +3472,7 @@ static int airoha_probe(struct platform_
 		if (!of_device_is_available(np))
 			continue;
 
-		err = airoha_alloc_gdm_port(eth, np, i++);
+		err = airoha_alloc_gdm_port(eth, np);
 		if (err) {
 			of_node_put(np);
 			goto error_napi_stop;
--- a/drivers/net/ethernet/airoha/airoha_ppe.c
+++ b/drivers/net/ethernet/airoha/airoha_ppe.c
@@ -316,7 +316,7 @@ static int airoha_ppe_foe_entry_prepare(
 			if (!airoha_is_valid_gdm_port(eth, port))
 				return -EINVAL;
 
-			if (dsa_port >= 0)
+			if (dsa_port >= 0 || eth->ports[1])
 				pse_port = port->id == 4 ? FE_PSE_PORT_GDM4
 							 : port->id;
 			else
@@ -337,7 +337,7 @@ static int airoha_ppe_foe_entry_prepare(
 			/* For downlink traffic consume SRAM memory for hw
 			 * forwarding descriptors queue.
 			 */
-			if (airhoa_is_lan_gdm_port(port))
+			if (airhoa_is_lan_gdm_port(eth, port))
 				val |= AIROHA_FOE_IB2_FAST_PATH;
 			if (dsa_port >= 0)
 				val |= FIELD_PREP(AIROHA_FOE_IB2_NBQ,
