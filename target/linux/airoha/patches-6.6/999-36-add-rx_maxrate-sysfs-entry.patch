From b40747ff393ecb79b8023c37b064f556463d08e4 Mon Sep 17 00:00:00 2001
Message-ID: <b40747ff393ecb79b8023c37b064f556463d08e4.1742458112.git.lorenzo@kernel.org>
From: Lorenzo Bianconi <lorenzo@kernel.org>
Date: Wed, 19 Mar 2025 22:30:50 +0100
Subject: [PATCH net-next] add rx_maxrate sysfs entry

Signed-off-by: Lorenzo Bianconi <lorenzo@kernel.org>
---
 drivers/net/ethernet/airoha/airoha_eth.c | 31 ++++++++++++++++
 include/linux/netdevice.h                |  7 ++++
 include/net/netdev_rx_queue.h            |  1 +
 net/core/net-sysfs.c                     | 47 ++++++++++++++++++++++++
 4 files changed, 86 insertions(+)

--- a/drivers/net/ethernet/airoha/airoha_eth.c
+++ b/drivers/net/ethernet/airoha/airoha_eth.c
@@ -12,6 +12,7 @@
 #include <linux/u64_stats_sync.h>
 #include <linux/regmap.h>
 #include <net/dst_metadata.h>
+#include <net/netdev_rx_queue.h>
 #include <net/page_pool/helpers.h>
 #include <net/pkt_cls.h>
 #include <uapi/linux/ppp_defs.h>
@@ -2731,6 +2732,30 @@ static int airoha_dev_tc_setup(struct ne
 	}
 }
 
+static int airoha_dev_set_rx_maxrate(struct net_device *dev, int queue,
+				     u32 rate)
+{
+	struct netdev_rx_queue *rxq = __netif_get_rx_queue(dev, queue);
+	struct airoha_gdm_port *port = netdev_priv(dev);
+	struct airoha_qdma *qdma = port->qdma;
+	u32 rate_val = rate * 1000; /* Kbps */
+	int err;
+
+	if (rate == rxq->rx_maxrate)
+		return 0;
+
+	if (!qdma->q_rx[queue].ndesc)
+		return -EINVAL;
+
+	err = airoha_qdma_init_rl_config(qdma, queue, !!rate,
+					 TRTCM_BYTE_UNIT);
+	if (err)
+		return err;
+
+	return airoha_qdma_set_rl_token_bucket(qdma, queue, rate_val,
+					       MIN_TOKEN_SIZE);
+}
+
 static const struct net_device_ops airoha_netdev_ops = {
 	.ndo_init		= airoha_dev_init,
 	.ndo_open		= airoha_dev_open,
@@ -2741,6 +2766,7 @@ static const struct net_device_ops airoh
 	.ndo_get_stats64        = airoha_dev_get_stats64,
 	.ndo_set_mac_address	= airoha_dev_set_macaddr,
 	.ndo_setup_tc		= airoha_dev_tc_setup,
+	.ndo_set_rx_maxrate	= airoha_dev_set_rx_maxrate,
 };
 
 static const struct ethtool_ops airoha_ethtool_ops = {
--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@ -1374,6 +1374,10 @@ struct netdev_net_notifier {
  *			     int queue_index, u32 maxrate);
  *	Called when a user wants to set a max-rate limitation of specific
  *	TX queue.
+ * int (*ndo_set_rx_maxrate)(struct net_device *dev,
+ *			     int queue_index, u32 maxrate);
+ *	Called when a user wants to set a max-rate limitation of specific
+ *	RX queue.
  * int (*ndo_get_iflink)(const struct net_device *dev);
  *	Called to get the iflink value of this device.
  * int (*ndo_fill_metadata_dst)(struct net_device *dev, struct sk_buff *skb);
@@ -1642,6 +1646,9 @@ struct net_device_ops {
 	int			(*ndo_set_tx_maxrate)(struct net_device *dev,
 						      int queue_index,
 						      u32 maxrate);
+	int			(*ndo_set_rx_maxrate)(struct net_device *dev,
+						      int queue_index,
+						      u32 maxrate);
 	int			(*ndo_get_iflink)(const struct net_device *dev);
 	int			(*ndo_fill_metadata_dst)(struct net_device *dev,
 						       struct sk_buff *skb);
--- a/include/net/netdev_rx_queue.h
+++ b/include/net/netdev_rx_queue.h
@@ -13,6 +13,7 @@ struct netdev_rx_queue {
 #ifdef CONFIG_RPS
 	struct rps_map __rcu		*rps_map;
 	struct rps_dev_flow_table __rcu	*rps_flow_table;
+	unsigned long			rx_maxrate;
 #endif
 	struct kobject			kobj;
 	struct net_device		*dev;
--- a/net/core/net-sysfs.c
+++ b/net/core/net-sysfs.c
@@ -990,18 +990,63 @@ static ssize_t store_rps_dev_flow_table_
 	return len;
 }
 
+static ssize_t rx_maxrate_show(struct netdev_rx_queue *queue, char *buf)
+{
+	return sysfs_emit(buf, "%lu\n", queue->rx_maxrate);
+}
+
+static ssize_t rx_maxrate_store(struct netdev_rx_queue *queue,
+				const char *buf, size_t len)
+{
+	int err, index = get_netdev_rx_queue_index(queue);
+	struct net_device *dev = queue->dev;
+	static DEFINE_MUTEX(rx_maxrate_mutex);
+	u32 rate;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	/* The check is also done later; this helps returning early without
+	 * hitting the locking section below.
+	 */
+	if (!dev->netdev_ops->ndo_set_rx_maxrate)
+		return -EOPNOTSUPP;
+
+	err = kstrtou32(buf, 10, &rate);
+	if (err < 0)
+		return err;
+
+	mutex_lock(&rx_maxrate_mutex);
+
+	err = -EOPNOTSUPP;
+	if (dev->netdev_ops->ndo_set_rx_maxrate)
+		err = dev->netdev_ops->ndo_set_rx_maxrate(dev, index, rate);
+
+	if (!err)
+		queue->rx_maxrate = rate;
+
+	mutex_unlock(&rx_maxrate_mutex);
+
+	return !err ? len : err;
+}
+
 static struct rx_queue_attribute rps_cpus_attribute __ro_after_init
 	= __ATTR(rps_cpus, 0644, show_rps_map, store_rps_map);
 
 static struct rx_queue_attribute rps_dev_flow_table_cnt_attribute __ro_after_init
 	= __ATTR(rps_flow_cnt, 0644,
 		 show_rps_dev_flow_table_cnt, store_rps_dev_flow_table_cnt);
+
+static struct rx_queue_attribute queue_rx_maxrate __ro_after_init
+	= __ATTR(rx_maxrate, 0644, rx_maxrate_show, rx_maxrate_store);
+
 #endif /* CONFIG_RPS */
 
 static struct attribute *rx_queue_default_attrs[] __ro_after_init = {
 #ifdef CONFIG_RPS
 	&rps_cpus_attribute.attr,
 	&rps_dev_flow_table_cnt_attribute.attr,
+	&queue_rx_maxrate.attr,
 #endif
 	NULL
 };
