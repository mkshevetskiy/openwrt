From 9c61a64f998e4c858accf0d54d0a7e272727d67d Mon Sep 17 00:00:00 2001
Message-ID: <9c61a64f998e4c858accf0d54d0a7e272727d67d.1749498104.git.lorenzo@kernel.org>
In-Reply-To: <6fd84b9d5ff07ca622c8559829e23c00bf7dc493.1749498104.git.lorenzo@kernel.org>
References: <6fd84b9d5ff07ca622c8559829e23c00bf7dc493.1749498104.git.lorenzo@kernel.org>
From: Lorenzo Bianconi <lorenzo@kernel.org>
Date: Mon, 9 Jun 2025 14:17:49 +0200
Subject: [PATCH net-next 2/2] net: airoha: Differentiate hwfd buffer size for
 QDMA0 and QDMA1

In oreder to reduce the required hwfd buffers queue size, differentiate
hwfd buffer size for QDMA0 and QDMA1 and use 2KB for QDMA0 and 256B for
QDMA1.

Signed-off-by: Lorenzo Bianconi <lorenzo@kernel.org>
---
 drivers/net/ethernet/airoha/airoha_eth.c | 20 ++++++++++++++++----
 1 file changed, 16 insertions(+), 4 deletions(-)

--- a/drivers/net/ethernet/airoha/airoha_eth.c
+++ b/drivers/net/ethernet/airoha/airoha_eth.c
@@ -1220,20 +1220,24 @@ static int airoha_qdma_init_hfwd_queues(
 	int size, index, num_desc = HW_DSCP_NUM;
 	struct airoha_eth *eth = qdma->eth;
 	int id = qdma - &eth->qdma[0];
+	u32 status, buf_size;
 	dma_addr_t dma_addr;
 	const char *name;
-	u32 status;
 
 	name = devm_kasprintf(eth->dev, GFP_KERNEL, "qdma%d-buf", id);
 	if (!name)
 		return -ENOMEM;
 
+	buf_size = id ? AIROHA_MAX_PACKET_SIZE / 2 : AIROHA_MAX_PACKET_SIZE;
 	index = of_property_match_string(eth->dev->of_node,
 					 "memory-region-names", name);
 	if (index >= 0) {
 		struct reserved_mem *rmem;
 		struct device_node *np;
 
+		/* Consume reserved memory for hw forwarding buffers queue if
+		 * available in the DTS
+		 */
 		np = of_parse_phandle(eth->dev->of_node, "memory-region",
 				      index);
 		if (!np)
@@ -1245,9 +1249,9 @@ static int airoha_qdma_init_hfwd_queues(
 		/* Compute the number of hw descriptors according to the
 		 * reserved memory size and the payload buffer size
 		 */
-		num_desc = rmem->size / AIROHA_MAX_PACKET_SIZE;
+		num_desc = div_u64(rmem->size, buf_size);
 	} else {
-		size = AIROHA_MAX_PACKET_SIZE * num_desc;
+		size = buf_size * num_desc;
 		if (!dmam_alloc_coherent(eth->dev, size, &dma_addr,
 					 GFP_KERNEL))
 			return -ENOMEM;
@@ -1260,12 +1264,12 @@ static int airoha_qdma_init_hfwd_queues(
 		return -ENOMEM;
 
 	airoha_qdma_wr(qdma, REG_FWD_DSCP_BASE, dma_addr);
+	/* QDMA0: 2KB. QDMA1: 1KB */
 	airoha_qdma_rmw(qdma, REG_HW_FWD_DSCP_CFG,
 			HW_FWD_DSCP_PAYLOAD_SIZE_MASK,
-			FIELD_PREP(HW_FWD_DSCP_PAYLOAD_SIZE_MASK, 0));
+			FIELD_PREP(HW_FWD_DSCP_PAYLOAD_SIZE_MASK, !!id));
 	airoha_qdma_rmw(qdma, REG_FWD_DSCP_LOW_THR, FWD_DSCP_LOW_THR_MASK,
 			FIELD_PREP(FWD_DSCP_LOW_THR_MASK, 128));
-
 	airoha_qdma_rmw(qdma, REG_LMGR_INIT_CFG,
 			LMGR_INIT_START | LMGR_SRAM_MODE_MASK |
 			HW_FWD_DESC_NUM_MASK,
