From 0861ebe1e50d924bbd4b9e1de4d4797ae8e42172 Mon Sep 17 00:00:00 2001
Message-ID: <0861ebe1e50d924bbd4b9e1de4d4797ae8e42172.1758815505.git.lorenzo@kernel.org>
In-Reply-To: <f8e2fa02a3000d80cf187acb55abc86cc3e9d2f0.1758815505.git.lorenzo@kernel.org>
References: <f8e2fa02a3000d80cf187acb55abc86cc3e9d2f0.1758815505.git.lorenzo@kernel.org>
From: Lorenzo Bianconi <lorenzo@kernel.org>
Date: Thu, 11 Sep 2025 10:31:26 +0200
Subject: [PATCH 4/4] net: airoha: Add AN7583 SoC support

Introduce support for AN7583 ethernet controller to airoha-eth dirver.

Signed-off-by: Lorenzo Bianconi <lorenzo@kernel.org>
---
 drivers/net/ethernet/airoha/airoha_eth.c | 39 +++++++++++++++++++++---
 drivers/net/ethernet/airoha/airoha_eth.h |  5 +++
 drivers/net/ethernet/airoha/airoha_ppe.c |  3 ++
 3 files changed, 43 insertions(+), 4 deletions(-)

--- a/drivers/net/ethernet/airoha/airoha_eth.c
+++ b/drivers/net/ethernet/airoha/airoha_eth.c
@@ -117,11 +117,13 @@ static int airoha_set_vip_for_gdm_port(s
 	switch (port->id) {
 	case 3:
 		/* FIXME: handle XSI_PCIE1_PORT */
-		vip_port = XSI_PCIE0_VIP_PORT_MASK;
+		vip_port = airoha_is_7581(eth) ? XSI_PCIE0_VIP_PORT_MASK
+					       : XSI_ETH_VIP_PORT_MASK;
 		break;
 	case 4:
 		/* FIXME: handle XSI_USB_PORT */
-		vip_port = XSI_ETH_VIP_PORT_MASK;
+		vip_port = airoha_is_7581(eth) ? XSI_ETH_VIP_PORT_MASK
+					       : XSI_PCIE0_VIP_PORT_MASK;
 		break;
 	default:
 		return 0;
@@ -1850,8 +1852,8 @@ static int airoha_dev_set_macaddr(struct
 static void airhoha_set_gdm2_loopback(struct airoha_gdm_port *port)
 {
 	u32 pse_port = port->id == 3 ? FE_PSE_PORT_GDM3 : FE_PSE_PORT_GDM4;
-	u32 src_port, chan = port->id == 3 ? 4 : 0;
 	struct airoha_eth *eth = port->qdma->eth;
+	u32 src_port, chan;
 
 	/* Forward the traffic to the proper GDM port */
 	airoha_set_gdm_port_fwd_cfg(eth, REG_GDM_FWD_CFG(2), pse_port);
@@ -1860,6 +1862,8 @@ static void airhoha_set_gdm2_loopback(st
 	/* Enable GDM2 loopback */
 	airoha_fe_wr(eth, REG_GDM_TXCHN_EN(2), 0xffffffff);
 	airoha_fe_wr(eth, REG_GDM_RXCHN_EN(2), 0xffff);
+
+	chan = port->id == 3 ? airoha_is_7581(eth) ? 4 : 3 : 0;
 	airoha_fe_rmw(eth, REG_GDM_LPBK_CFG(2),
 		      LPBK_CHAN_MASK | LPBK_MODE_MASK | LPBK_EN_MASK,
 		      FIELD_PREP(LPBK_CHAN_MASK, chan) |
@@ -1885,7 +1889,7 @@ static void airhoha_set_gdm2_loopback(st
 		      SP_CPORT_MASK(src_port & 0x7),
 		      FE_PSE_PORT_CDM2 << __ffs(SP_CPORT_MASK(src_port & 0x7)));
 
-	if (port->id != 3)
+	if (port->id != 3 && airoha_is_7581(eth))
 		airoha_fe_rmw(eth, REG_SRC_PORT_FC_MAP6,
 			      FC_ID_OF_SRC_PORT24_MASK,
 			      FIELD_PREP(FC_ID_OF_SRC_PORT24_MASK, 2));
@@ -2074,6 +2078,20 @@ static int airoha_dev_set_features(struc
 	return 0;
 }
 
+static int airoha_get_fe_port(struct airoha_gdm_port *port)
+{
+	struct airoha_qdma *qdma = port->qdma;
+	struct airoha_eth *eth = qdma->eth;
+
+	switch (eth->soc->version) {
+	case 0x7583:
+		return port->id == 3 ? FE_PSE_PORT_GDM3 : port->id;
+	case 0x7581:
+	default:
+		return port->id == 4 ? FE_PSE_PORT_GDM4 : port->id;
+	}
+}
+
 static netdev_tx_t airoha_dev_xmit(struct sk_buff *skb,
 				   struct net_device *dev)
 {
@@ -2114,7 +2132,7 @@ static netdev_tx_t airoha_dev_xmit(struc
 		}
 	}
 
-	fport = port->id == 4 ? FE_PSE_PORT_GDM4 : port->id;
+	fport = airoha_get_fe_port(port);
 	msg1 = FIELD_PREP(QDMA_ETH_TXMSG_FPORT_MASK, fport) |
 	       FIELD_PREP(QDMA_ETH_TXMSG_METER_MASK, 0x7f);
 
@@ -3538,6 +3556,12 @@ static const char * const en7581_xsi_rst
 	"xfp-mac",
 };
 
+static const char * const an7583_xsi_rsts_names[] = {
+	"hsi0-mac",
+	"hsi1-mac",
+	"xfp-mac",
+};
+
 static const struct airoha_eth_soc_data en7581_soc_data = {
 	.version = 0x7581,
 	.xsi_rsts_names = en7581_xsi_rsts_names,
@@ -3545,8 +3569,16 @@ static const struct airoha_eth_soc_data
 	.num_ppe = 2,
 };
 
+static const struct airoha_eth_soc_data an7583_soc_data = {
+	.version = 0x7583,
+	.xsi_rsts_names = an7583_xsi_rsts_names,
+	.num_xsi_rsts = ARRAY_SIZE(an7583_xsi_rsts_names),
+	.num_ppe = 1,
+};
+
 static const struct of_device_id of_airoha_match[] = {
 	{ .compatible = "airoha,en7581-eth", .data = &en7581_soc_data },
+	{ .compatible = "airoha,an7583-eth", .data = &an7583_soc_data },
 	{ /* sentinel */ }
 };
 MODULE_DEVICE_TABLE(of, of_airoha_match);
--- a/drivers/net/ethernet/airoha/airoha_eth.h
+++ b/drivers/net/ethernet/airoha/airoha_eth.h
@@ -648,6 +648,11 @@ static inline bool airoha_is_7581(struct
 	return eth->soc->version == 0x7581;
 }
 
+static inline bool airoha_is_7583(struct airoha_eth *eth)
+{
+	return eth->soc->version == 0x7583;
+}
+
 bool airoha_is_valid_gdm_port(struct airoha_eth *eth,
 			      struct airoha_gdm_port *port);
 
--- a/drivers/net/ethernet/airoha/airoha_ppe.c
+++ b/drivers/net/ethernet/airoha/airoha_ppe.c
@@ -36,6 +36,9 @@ static int airoha_ppe_get_num_stats_entr
 					    u32 *num_stats)
 {
 #ifdef CONFIG_NET_AIROHA_FLOW_STATS
+	if (airoha_is_7583(ppe->eth))
+		return -EOPNOTSUPP;
+
 	*num_stats = PPE_STATS_NUM_ENTRIES;
 	return 0;
 #else
