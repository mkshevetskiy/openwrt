From dd78d2b2536989da16ba9a960938a1b6609b8b14 Mon Sep 17 00:00:00 2001
From: Christian Marangi <ansuelsmth@gmail.com>
Date: Sun, 24 Aug 2025 23:35:44 +0200
Subject: [PATCH 3/3] ASoC: airoha: add support for PCM driver

The Airoha AN7581 SoC have alternative PCM interface for the I2S. This
is dedicated for VoIP application.

Signed-off-by: Christian Marangi <ansuelsmth@gmail.com>
---
 sound/soc/airoha/Kconfig                    |   9 +
 sound/soc/airoha/an7581/Makefile            |   1 +
 sound/soc/airoha/an7581/an7581-afe-common.h |  11 +
 sound/soc/airoha/an7581/an7581-i2s.c        |   9 +-
 sound/soc/airoha/an7581/an7581-pcm.c        | 598 ++++++++++++++++++++
 5 files changed, 627 insertions(+), 1 deletion(-)
 create mode 100644 sound/soc/airoha/an7581/an7581-pcm.c

diff --git a/sound/soc/airoha/Kconfig b/sound/soc/airoha/Kconfig
index 7c271c164f1f..4f81acb3b04e 100644
--- a/sound/soc/airoha/Kconfig
+++ b/sound/soc/airoha/Kconfig
@@ -17,3 +17,12 @@ config SND_SOC_AN7581_I2S
 	  that can be used with other codecs.
 	  Select Y if you have such device.
 	  If unsure select "N".
+
+config SND_SOC_AN7581_PCM
+	tristate "PCM support for Airoha AN7581 chip"
+	depends on SND_SOC_AN7581_I2S
+	help
+	  This adds PCM driver for Airoha AN7581 boards
+	  that can be used with other codecs.
+	  Select Y if you have such device.
+	  If unsure select "N".
diff --git a/sound/soc/airoha/an7581/Makefile b/sound/soc/airoha/an7581/Makefile
index 8cec1a48dc89..ab689e3f0bcf 100644
--- a/sound/soc/airoha/an7581/Makefile
+++ b/sound/soc/airoha/an7581/Makefile
@@ -6,3 +6,4 @@ snd-soc-an7581-afe-y := \
 
 obj-$(CONFIG_SND_SOC_AN7581) += snd-soc-an7581-afe.o
 obj-$(CONFIG_SND_SOC_AN7581_I2S) += an7581-i2s.o
+obj-$(CONFIG_SND_SOC_AN7581_PCM) += an7581-pcm.o
diff --git a/sound/soc/airoha/an7581/an7581-afe-common.h b/sound/soc/airoha/an7581/an7581-afe-common.h
index 233f12e77d32..7ed93843c01e 100644
--- a/sound/soc/airoha/an7581/an7581-afe-common.h
+++ b/sound/soc/airoha/an7581/an7581-afe-common.h
@@ -32,4 +32,15 @@ struct an7581_afe_private {
 unsigned int an7581_afe_rate_transform(struct device *dev,
 				       unsigned int rate);
 
+#ifdef CONFIG_SND_SOC_AN7581_PCM
+int an7581_pcm_setup(struct snd_soc_card *card,
+		     struct device_node *np);
+#else
+static inline int an7581_pcm_setup(struct snd_soc_card *card,
+				   struct device_node *np)
+{
+	return -EOPNOTSUPP;
+}
+#endif
+
 #endif
diff --git a/sound/soc/airoha/an7581/an7581-i2s.c b/sound/soc/airoha/an7581/an7581-i2s.c
index 542caa107921..6fd16e79e114 100644
--- a/sound/soc/airoha/an7581/an7581-i2s.c
+++ b/sound/soc/airoha/an7581/an7581-i2s.c
@@ -51,8 +51,8 @@ static int an7581_i2s_machine_probe(struct platform_device *pdev)
 {
 	struct snd_soc_card *card = &an7581_i2s_card;
 	struct device_node *platform_dai_node;
+	struct device_node *platform, *pcm;
 	struct snd_soc_dai_link *dai_link;
-	struct device_node *platform;
 	int ret, i;
 
 	card->dev = &pdev->dev;
@@ -84,6 +84,13 @@ static int an7581_i2s_machine_probe(struct platform_device *pdev)
 		goto err_of_node_put;
 	}
 
+	pcm = of_get_child_by_name(pdev->dev.of_node, "pcm");
+	if (pcm) {
+		ret = an7581_pcm_setup(card, pcm);
+		if (ret != -EOPNOTSUPP)
+			return ret;
+	}
+
 	return 0;
 
 err_of_node_put:
diff --git a/sound/soc/airoha/an7581/an7581-pcm.c b/sound/soc/airoha/an7581/an7581-pcm.c
new file mode 100644
index 000000000000..66ca430e90b1
--- /dev/null
+++ b/sound/soc/airoha/an7581/an7581-pcm.c
@@ -0,0 +1,598 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Airoha ALSA SoC PCM platform driver for AN7581
+ *
+ */
+
+#include <linux/bitfield.h>
+#include <linux/dma-mapping.h>
+#include <linux/mfd/syscon.h>
+#include <linux/module.h>
+#include <linux/of_irq.h>
+#include <linux/regmap.h>
+#include <linux/reset.h>
+#include <linux/spinlock.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+
+#include "an7581-afe-common.h"
+
+#define AN7581_PCM_PICR				0x0
+#define   AN7581_PCM_CFG_VALID			BIT(26)
+#define   AN7581_PCM_SAMPLE_CLK			BIT(4)
+#define     AN7581_PCM_SAMPLE_CLK_8KHZ		FIELD_PREP_CONST(AN7581_PCM_SAMPLE_CLK, 0x0)
+#define     AN7581_PCM_SAMPLE_CLK_16KHZ		FIELD_PREP_CONST(AN7581_PCM_SAMPLE_CLK, 0x1)
+#define   AN7581_PCM_BIT_CLK			GENMASK(3, 1)
+#define     AN7581_PCM_BIT_CLK_256KHZ		FIELD_PREP_CONST(AN7581_PCM_BIT_CLK, 0x0)
+#define     AN7581_PCM_BIT_CLK_512KHZ		FIELD_PREP_CONST(AN7581_PCM_BIT_CLK, 0x1)
+#define     AN7581_PCM_BIT_CLK_1024KHZ		FIELD_PREP_CONST(AN7581_PCM_BIT_CLK, 0x2)
+#define     AN7581_PCM_BIT_CLK_2048HZ		FIELD_PREP_CONST(AN7581_PCM_BIT_CLK, 0x3)
+#define     AN7581_PCM_BIT_CLK_4096KHZ		FIELD_PREP_CONST(AN7581_PCM_BIT_CLK, 0x4)
+#define     AN7581_PCM_BIT_CLK_8192KHZ		FIELD_PREP_CONST(AN7581_PCM_BIT_CLK, 0x5)
+#define   AN7581_PCM_BIT_MSTSLV_MODE		BIT(0)
+#define     AN7581_PCM_BIT_MSTSLV_MODE_MASTER	FIELD_PREP_CONST(AN7581_PCM_BIT_MSTSLV_MODE, 0x0)
+#define     AN7581_PCM_BIT_MSTSLV_MODE_SLAVE	FIELD_PREP_CONST(AN7581_PCM_BIT_MSTSLV_MODE, 0x1)
+/* Same bitmap for all TX timeslot reg */
+#define AN7581_PCM_PTTSCR0			0x4
+#define   AN7581_PCM_TXTS1_BW			BIT(28)
+#define     AN7581_PCM_TXTS1_BW_8BIT		FIELD_PREP_CONST(AN7581_PCM_TXTS1_BW, 0x0)
+#define     AN7581_PCM_TXTS1_BW_16BIT		FIELD_PREP_CONST(AN7581_PCM_TXTS1_BW, 0x1)
+#define   AN7581_PCM_TXTS1_START		GENMASK(25, 16)
+#define   AN7581_PCM_TXTS0_BW			BIT(12)
+#define     AN7581_PCM_TXTS0_BW_8BIT		FIELD_PREP_CONST(AN7581_PCM_TXTS0_BW, 0x0)
+#define     AN7581_PCM_TXTS0_BW_16BIT		FIELD_PREP_CONST(AN7581_PCM_TXTS0_BW, 0x1)
+#define   AN7581_PCM_TXTS0_START		GENMASK(9, 0)
+#define AN7581_PCM_PTTSCR1			0x8
+#define AN7581_PCM_PTTSCR2			0xc
+#define AN7581_PCM_PTTSCR3			0x10
+/* Same bitmap for all RX timeslot reg */
+#define AN7581_PCM_PRTSCR0			0x14
+#define   AN7581_PCM_RXTS1_BW			BIT(28)
+#define     AN7581_PCM_RXTS1_BW_8BIT		FIELD_PREP_CONST(AN7581_PCM_RXTS1_BW, 0x0)
+#define     AN7581_PCM_RXTS1_BW_16BIT		FIELD_PREP_CONST(AN7581_PCM_RXTS1_BW, 0x1)
+#define   AN7581_PCM_RXTS1_START		GENMASK(25, 16)
+#define   AN7581_PCM_RXTS0_BW			BIT(12)
+#define     AN7581_PCM_RXTS0_BW_8BIT		FIELD_PREP_CONST(AN7581_PCM_RXTS0_BW, 0x0)
+#define     AN7581_PCM_RXTS0_BW_16BIT		FIELD_PREP_CONST(AN7581_PCM_RXTS0_BW, 0x1)
+#define   AN7581_PCM_RXTS0_START		GENMASK(9, 0)
+#define AN7581_PCM_PRTSCR1			0x18
+#define AN7581_PCM_PRTSCR2			0x1c
+#define AN7581_PCM_PRTSCR3			0x20
+#define AN7581_PCM_ISR				0x24
+#define AN7581_PCM_IMR				0x28
+#define   AN7581_PCM_IMR_ISI2_INT		BIT(16)
+#define   AN7581_PCM_IMR_ZSI2_INT		BIT(15)
+#define   AN7581_PCM_IMR_SLIC_INT		BIT(14)
+#define   AN7581_PCM_IMR_SFC_INT		BIT(13)
+#define   AN7581_PCM_IMR_ISI1_INT		BIT(12)
+#define   AN7581_PCM_IMR_ZSI1_INT		BIT(11)
+#define   AN7581_PCM_IMR_HUNT_OVERTIME_INT	BIT(10)
+#define   AN7581_PCM_IMR_HUNT_ERR_INT		BIT(9)
+#define   AN7581_PCM_IMR_AHB_BUS_ERR_INT	BIT(8)
+#define   AN7581_PCM_IMR_RBUF_OVERRUN_INT	BIT(7)
+#define   AN7581_PCM_IMR_TBUF_UNDERRUN_INT	BIT(6)
+#define   AN7581_PCM_IMR_RDESC_END_INT		BIT(5)
+#define   AN7581_PCM_IMR_TDESC_END_INT		BIT(4)
+#define   AN7581_PCM_IMR_RDESC_UPDATE_INT	BIT(3)
+#define   AN7581_PCM_IMR_TDESC_UPDATE_INT	BIT(2)
+#define   AN7581_PCM_IMR_TXRX_FB_INT		BIT(0)
+#define AN7581_PCM_TPDR				0x2c
+#define   AN7581_PCM_TX_POLLING			BIT(0)
+#define AN7581_PCM_RPDR				0x30
+#define   AN7581_PCM_RX_POLLING			BIT(0)
+#define AN7581_PCM_TDRBAR			0x34
+#define   AN7581_TDESC_BASE			GENMASK(31, 0)
+#define AN7581_PCM_RDRBAR			0x38
+#define   AN7581_RDESC_BASE			GENMASK(31, 0)
+#define AN7581_PCM_TRDRSR			0x3c
+#define   AN7581_DESC_OFFSET			GENMASK(7, 4)
+#define   AN7581_DESC_SIZE			GENMASK(3, 0)
+#define AN7581_PCM_TRDCR			0x40
+#define   AN7581_PCM_DMA_POLICY			GENMASK(3, 2)
+#define   AN7581_PCM_DMA_POLICY_RR		FIELD_PREP_CONST(AN7581_PCM_DMA_POLICY, 0x0)
+#define   AN7581_PCM_DMA_POLICY_RSVD		FIELD_PREP_CONST(AN7581_PCM_DMA_POLICY, 0x1)
+#define   AN7581_PCM_DMA_POLICY_TX_PRIORITY	FIELD_PREP_CONST(AN7581_PCM_DMA_POLICY, 0x2)
+#define   AN7581_PCM_DMA_POLICY_RX_PRIORITY	FIELD_PREP_CONST(AN7581_PCM_DMA_POLICY, 0x3)
+#define   AN7581_PCM_RXDMA_ENABLE		BIT(0)
+#define   AN7581_PCM_TXDMA_ENABLE		BIT(0)
+#define AN7581_PCM_PTTSCR4			0x48
+#define AN7581_PCM_PTTSCR5			0x4c
+#define AN7581_PCM_PTTSCR6			0x50
+#define AN7581_PCM_PTTSCR7			0x54
+#define AN7581_PCM_PTTSCR8			0x58
+#define AN7581_PCM_PTTSCR9			0x5c
+#define AN7581_PCM_PTTSCR10			0x60
+#define AN7581_PCM_PTTSCR11			0x64
+#define AN7581_PCM_PTTSCR12			0x68
+#define AN7581_PCM_PTTSCR13			0x6c
+#define AN7581_PCM_PTTSCR14			0x70
+#define AN7581_PCM_PTTSCR15			0x74
+#define AN7581_PCM_PTTSCR(chan)			((chan) / 2 < 8 ? AN7581_PCM_PTTSCR0 : AN7581_PCM_PTTSCR4)
+#define   AN7581_PCM_TXTS_BW(chan)		((chan) % 2 ? AN7581_PCM_TXTS0_BW : AN7581_PCM_TXTS1_BW)
+#define     AN7581_PCM_TXTS_BW_8BIT(chan)	0x0
+#define     AN7581_PCM_TXTS_BW_16BIT(chan)	AN7581_PCM_TXTS_BW(chan)
+#define   AN7581_PCM_TXTS_START(chan)		((chan) % 2 ? AN7581_PCM_TXTS0_START : AN7581_PCM_TXTS1_START)
+#define AN7581_PCM_PRTSCR4			0x78
+#define AN7581_PCM_PRTSCR5			0x7c
+#define AN7581_PCM_PRTSCR6			0x80
+#define AN7581_PCM_PRTSCR7			0x84
+#define AN7581_PCM_PRTSCR8			0x88
+#define AN7581_PCM_PRTSCR9			0x8c
+#define AN7581_PCM_PRTSCR10			0x90
+#define AN7581_PCM_PRTSCR11			0x94
+#define AN7581_PCM_PRTSCR12			0x98
+#define AN7581_PCM_PRTSCR13			0x9c
+#define AN7581_PCM_PRTSCR14			0xa0
+#define AN7581_PCM_PRTSCR15			0xa4
+#define AN7581_PCM_PRTSCR(chan)			((chan) / 2 < 8 ? AN7581_PCM_PRTSCR0 : AN7581_PCM_PRTSCR4)
+#define   AN7581_PCM_RXTS_BW(chan)		((chan) % 2 ? AN7581_PCM_RXTS0_BW : AN7581_PCM_RXTS1_BW)
+#define     AN7581_PCM_RXTS_BW_8BIT(chan)	0x0
+#define     AN7581_PCM_RXTS_BW_16BIT(chan)	AN7581_PCM_TXTS_BW(chan)
+#define   AN7581_PCM_RXTS_START(chan)		((chan) % 2 ? AN7581_PCM_RXTS0_START : AN7581_PCM_RXTS1_START)
+#define AN7581_PCM_CHBFOSR			0xa8
+#define   AN7581_PCM_DESC_CHBF_OFFSET		GENMASK(15, 0)
+#define AN7581_PCM_DCHENR			0xac
+/* Each channel correspond to a bit.
+ * Example:
+ * BIT(0) -> chan 0
+ * BIT(1) -> chan 1
+ * ...
+ *
+ * Notice that it's expected the channel are sequential
+ * aka it's not possible to have empty channel in between.
+ * (example BIT(0) | BIT(2))
+ */
+#define   AN7581_PCM_CHAN_EN			GENMASK(31, 0)
+
+#define AN7581_PCM_MAX_CHANNELS			32
+#define AN7581_PCM_TX_DESCRIPTORS		15
+#define AN7581_PCM_RX_DESCRIPTORS		15
+#define AN7581_PCM_DESCRIPTORS			(AN7581_PCM_TX_DESCRIPTORS + AN7581_PCM_RX_DESCRIPTORS)
+#define AN7581_PCM_SAMPLE_SIZE			80
+#define AN7581_PCM_BUFFER_SIZE			160
+
+#define AN7581_PCM_DESC_STATUS_OWNERSHIP	BIT(31)
+#define AN7581_PCM_DESC_STATUS_OWNERSHIP_CPU	FIELD_PREP_CONST(AN7581_PCM_DESC_STATUS_OWNERSHIP, 0x0)
+#define AN7581_PCM_DESC_STATUS_OWNERSHIP_DMA	FIELD_PREP_CONST(AN7581_PCM_DESC_STATUS_OWNERSHIP, 0x1)
+#define AN7581_PCM_DESC_STATUS_SAMPLE_SIZE	GENMASK(9, 0)
+
+struct an7581_pcm_desc {
+	u32 status;
+	u32 channel_mask;
+	dma_addr_t buf;
+};
+
+enum an7581_pcm_direction {
+	AN7581_PCM_PLAYBACK,
+	AN7581_PCM_CAPTURE,
+};
+
+enum an7581_pcm_bitwidth {
+	AN7581_PCM_BITWIDTH_8BIT = 8,
+	AN7581_PCM_BITWIDTH_16BIT = 16,
+};
+
+struct an7581_pcm_priv {
+	struct device *dev;
+	struct regmap *map;
+	struct reset_control *reset;
+
+	struct snd_pcm_substream *playback_stream;
+	struct snd_pcm_substream *capture_stream;
+
+	/* Protect descriptor idx */
+	spinlock_t desc_lock;
+
+	struct an7581_pcm_desc *tx_descs;
+	int tx_desc_idx;
+	dma_addr_t tx_dma;
+
+	struct an7581_pcm_desc *rx_descs;
+	int rx_desc_idx;
+	dma_addr_t rx_dma;
+};
+
+static const struct snd_pcm_hardware an7581_pcm_hardware = {
+	.info			= SNDRV_PCM_INFO_MMAP |
+				  SNDRV_PCM_INFO_MMAP_VALID |
+				  SNDRV_PCM_INFO_INTERLEAVED,
+	.formats		= SNDRV_PCM_FMTBIT_U8,
+	.buffer_bytes_max	= AN7581_PCM_BUFFER_SIZE,
+	.periods_min		= AN7581_PCM_SAMPLE_SIZE,
+	.periods_max		= AN7581_PCM_BUFFER_SIZE / AN7581_PCM_SAMPLE_SIZE,
+	.channels_min		= 1,
+	.channels_max		= AN7581_PCM_MAX_CHANNELS,
+};
+
+static int an7581_pcm_setup_time_slot(struct an7581_pcm_priv *priv,
+				      int direction, int bit_width)
+{
+	int bit_counter = 0;
+	int chan;
+
+	for (chan = 0; chan < AN7581_PCM_MAX_CHANNELS; chan++) {
+		u32 mask, val;
+
+		if (direction == SNDRV_PCM_STREAM_PLAYBACK) {
+			mask = AN7581_PCM_TXTS_BW(chan) |
+			       AN7581_PCM_TXTS_START(chan);
+
+			if (bit_width == 8)
+				val = AN7581_PCM_TXTS_BW_8BIT(chan);
+			else
+				val = AN7581_PCM_TXTS_BW_16BIT(chan);
+			val |= bit_counter << __bf_shf(AN7581_PCM_TXTS_START(chan));
+		} else {
+			mask = AN7581_PCM_RXTS_BW(chan) |
+			       AN7581_PCM_RXTS_START(chan);
+
+			if (bit_width == 8)
+				val = AN7581_PCM_RXTS_BW_8BIT(chan);
+			else
+				val = AN7581_PCM_RXTS_BW_16BIT(chan);
+			val |= bit_counter << __bf_shf(AN7581_PCM_RXTS_START(chan));
+		}
+
+		regmap_update_bits(priv->map, AN7581_PCM_PTTSCR(chan),
+				   mask, val);
+
+		bit_counter += bit_width;
+	}
+
+	return 0;
+}
+
+static int an7581_pcm_open(struct snd_pcm_substream *substream)
+{
+	struct an7581_pcm_priv *priv = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		priv->playback_stream = substream;
+	else
+		priv->capture_stream = substream;
+
+	/* On open mask interrupt and disable DMA */
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		regmap_clear_bits(priv->map, AN7581_PCM_IMR,
+				  AN7581_PCM_IMR_TDESC_END_INT |
+				  AN7581_PCM_IMR_TDESC_UPDATE_INT);
+		regmap_clear_bits(priv->map, AN7581_PCM_TRDCR,
+				  AN7581_PCM_TXDMA_ENABLE);
+	} else {
+		regmap_clear_bits(priv->map, AN7581_PCM_IMR,
+				  AN7581_PCM_IMR_RDESC_END_INT |
+				  AN7581_PCM_IMR_RDESC_UPDATE_INT);
+		regmap_clear_bits(priv->map, AN7581_PCM_TRDCR,
+				  AN7581_PCM_RXDMA_ENABLE);
+	}
+
+	usleep_range(10, 20);
+
+	regmap_clear_bits(priv->map, AN7581_PCM_PICR,
+			  AN7581_PCM_CFG_VALID);
+
+	usleep_range(5000, 10000);
+
+	/* Enable channels */
+	regmap_update_bits(priv->map, AN7581_PCM_DCHENR,
+			   AN7581_PCM_CHAN_EN,
+			   FIELD_PREP(AN7581_PCM_CHAN_EN,
+				      BIT(AN7581_PCM_MAX_CHANNELS) - 1));
+
+	/* Enable interrupt */
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		regmap_set_bits(priv->map, AN7581_PCM_IMR,
+				AN7581_PCM_IMR_TDESC_END_INT |
+				AN7581_PCM_IMR_TDESC_UPDATE_INT);
+	} else {
+		regmap_set_bits(priv->map, AN7581_PCM_IMR,
+				AN7581_PCM_IMR_RDESC_END_INT |
+				AN7581_PCM_IMR_RDESC_UPDATE_INT);
+	}
+
+	snd_soc_set_runtime_hwparams(substream, &an7581_pcm_hardware);
+	snd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS);
+
+	return 0;
+}
+
+static int an7581_pcm_close(struct snd_pcm_substream *substream)
+{
+	struct an7581_pcm_priv *priv = snd_pcm_substream_chip(substream);
+
+	/* On close mask interrupt and disable DMA */
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		regmap_clear_bits(priv->map, AN7581_PCM_IMR,
+				  AN7581_PCM_IMR_TDESC_END_INT |
+				  AN7581_PCM_IMR_TDESC_UPDATE_INT);
+		regmap_clear_bits(priv->map, AN7581_PCM_TRDCR,
+				  AN7581_PCM_TXDMA_ENABLE);
+	} else {
+		regmap_clear_bits(priv->map, AN7581_PCM_IMR,
+				  AN7581_PCM_IMR_RDESC_END_INT |
+				  AN7581_PCM_IMR_RDESC_UPDATE_INT);
+		regmap_clear_bits(priv->map, AN7581_PCM_TRDCR,
+				  AN7581_PCM_RXDMA_ENABLE);
+	}
+
+	usleep_range(10, 20);
+
+	regmap_clear_bits(priv->map, AN7581_PCM_PICR,
+			  AN7581_PCM_CFG_VALID);
+
+	return 0;
+}
+
+static int an7581_pcm_prepare(struct snd_pcm_substream *substream)
+{
+	return 0;
+}
+
+static int an7581_pcm_hw_params(struct snd_pcm_substream *substream,
+				struct snd_pcm_hw_params *params)
+{
+	struct an7581_pcm_priv *priv = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct an7581_pcm_desc *desc;
+	int num_desc, i;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		desc = priv->tx_descs;
+		num_desc = AN7581_PCM_TX_DESCRIPTORS;
+	} else {
+		desc = priv->rx_descs;
+		num_desc = AN7581_PCM_RX_DESCRIPTORS;
+	}
+
+	/* Setup timeslot */
+	an7581_pcm_setup_time_slot(priv, substream->stream, params_width(params));
+
+	/* Setup Descriptor size and number */
+	regmap_update_bits(priv->map, AN7581_PCM_TRDRSR,
+			   AN7581_DESC_OFFSET | AN7581_DESC_SIZE,
+			   FIELD_PREP(AN7581_DESC_OFFSET, sizeof(*desc) / sizeof(u32) |
+			   FIELD_PREP(AN7581_DESC_SIZE, AN7581_PCM_TX_DESCRIPTORS)));
+
+	/* FIXME: Confirm this actually set buffer size */
+	regmap_update_bits(priv->map, AN7581_PCM_CHBFOSR,
+			   AN7581_PCM_DESC_CHBF_OFFSET,
+			   FIELD_PREP(AN7581_PCM_DESC_CHBF_OFFSET,
+				      AN7581_PCM_BUFFER_SIZE));
+
+	/* Configure each RX descriptor for DMA ownership and sample size */
+	for (i = 0; i < num_desc; i++) {
+		/* Assign to each descriptor the dma_addr + offset of period bytes */
+		desc->buf = runtime->dma_addr + (i * params_period_bytes(params));
+		desc->status = AN7581_PCM_DESC_STATUS_OWNERSHIP_DMA |
+				  FIELD_PREP(AN7581_PCM_DESC_STATUS_SAMPLE_SIZE,
+					     AN7581_PCM_SAMPLE_SIZE);
+		desc->channel_mask = BIT(AN7581_PCM_MAX_CHANNELS) - 1;
+
+		desc++;
+	}
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		regmap_set_bits(priv->map, AN7581_PCM_TRDCR,
+				AN7581_PCM_TXDMA_ENABLE);
+	else
+		regmap_set_bits(priv->map, AN7581_PCM_TRDCR,
+				AN7581_PCM_RXDMA_ENABLE);
+
+	/* Signal PCM configuration is now valid */
+	regmap_set_bits(priv->map, AN7581_PCM_PICR,
+			AN7581_PCM_CFG_VALID);
+
+	return 0;
+}
+
+static int an7581_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
+{
+	struct an7581_pcm_priv *priv = snd_pcm_substream_chip(substream);
+	unsigned long flags;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		/* Trigger PCM to POLL new descriptor */
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			rcu_assign_pointer(priv->playback_stream, substream);
+
+			spin_lock_irqsave(&priv->desc_lock, flags);
+			priv->rx_desc_idx = 0;
+			spin_unlock_irqrestore(&priv->desc_lock, flags);
+
+			regmap_set_bits(priv->map, AN7581_PCM_TPDR,
+					AN7581_PCM_TX_POLLING);
+		} else {
+			rcu_assign_pointer(priv->capture_stream, substream);
+
+			spin_lock_irqsave(&priv->desc_lock, flags);
+			priv->tx_desc_idx = 0;
+			spin_unlock_irqrestore(&priv->desc_lock, flags);
+
+			regmap_set_bits(priv->map, AN7581_PCM_RPDR,
+					AN7581_PCM_RX_POLLING);
+		}
+
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+			rcu_assign_pointer(priv->playback_stream, NULL);
+		else
+			rcu_assign_pointer(priv->capture_stream, NULL);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static snd_pcm_uframes_t an7581_pcm_pointer(struct snd_pcm_substream *substream)
+{
+	struct an7581_pcm_priv *priv = snd_pcm_substream_chip(substream);
+	unsigned long flags;
+	int idx;
+
+	spin_lock_irqsave(&priv->desc_lock, flags);
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		idx = priv->tx_desc_idx;
+	else
+		idx = priv->rx_desc_idx;
+
+	spin_unlock_irqrestore(&priv->desc_lock, flags);
+
+	return idx;
+}
+
+static irqreturn_t an7581_pcm_irq_handler(int irq, void *data)
+{
+	struct snd_pcm_substream *substream;
+	struct an7581_pcm_priv *priv = data;
+	unsigned long flags;
+	u32 isr;
+	int i;
+
+	regmap_read(priv->map, AN7581_PCM_ISR, &isr);
+
+	/* Scan descriptor on receiving RX desc update interrupt */
+	if (isr & AN7581_PCM_IMR_RDESC_UPDATE_INT) {
+		spin_lock_irqsave(&priv->desc_lock, flags);
+
+		for (i = 0; i < AN7581_PCM_RX_DESCRIPTORS; i++) {
+			if (FIELD_GET(AN7581_PCM_DESC_STATUS_OWNERSHIP,
+				      priv->rx_descs[i].status) ==
+			    AN7581_PCM_DESC_STATUS_OWNERSHIP_CPU)
+				priv->rx_desc_idx++;
+		}
+
+		spin_unlock_irqrestore(&priv->desc_lock, flags);
+	}
+
+	/* Scan descriptor on receiving TX desc update interrupt */
+	if (isr & AN7581_PCM_IMR_TDESC_UPDATE_INT) {
+		spin_lock_irqsave(&priv->desc_lock, flags);
+
+		for (i = 0; i < AN7581_PCM_TX_DESCRIPTORS; i++) {
+			if (FIELD_GET(AN7581_PCM_DESC_STATUS_OWNERSHIP,
+				      priv->tx_descs[i].status) ==
+			    AN7581_PCM_DESC_STATUS_OWNERSHIP_CPU)
+				priv->tx_desc_idx++;
+		}
+
+		spin_unlock_irqrestore(&priv->desc_lock, flags);
+	}
+
+	/* Signal elapsed if we are finished handling TX/RX frame */
+	if (isr & AN7581_PCM_IMR_RDESC_END_INT ||
+	    isr & AN7581_PCM_IMR_TDESC_END_INT) {
+		rcu_read_lock();
+
+		if (isr & AN7581_PCM_IMR_TDESC_END_INT) {
+			substream = rcu_dereference(priv->playback_stream);
+
+			if (substream && snd_pcm_running(substream))
+				snd_pcm_period_elapsed(substream);
+		}
+
+		if (isr & AN7581_PCM_IMR_RDESC_END_INT) {
+			substream = rcu_dereference(priv->capture_stream);
+
+			if (substream && snd_pcm_running(substream))
+				snd_pcm_period_elapsed(substream);
+		}
+
+		rcu_read_unlock();
+	}
+
+	return IRQ_HANDLED;
+}
+
+static const struct snd_pcm_ops an7581_pcm_ops = {
+	.open		= an7581_pcm_open,
+	.close		= an7581_pcm_close,
+	.prepare	= an7581_pcm_prepare,
+	.hw_params	= an7581_pcm_hw_params,
+	.trigger	= an7581_pcm_trigger,
+	.pointer	= an7581_pcm_pointer,
+};
+
+int an7581_pcm_setup(struct snd_soc_card *soc_card,
+		     struct device_node *np)
+{
+	struct snd_card *card = soc_card->snd_card;
+	struct device *dev = soc_card->dev;
+	struct an7581_pcm_priv *priv;
+	struct snd_pcm *pcm;
+	int irq;
+	int ret;
+
+	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	priv->map = device_node_to_regmap(dev->of_node);
+	if (!IS_ERR(priv->map))
+		return PTR_ERR(priv->map);
+
+	priv->reset = devm_reset_control_get_exclusive(dev, "pcm1");
+	if (IS_ERR(priv->reset))
+		return PTR_ERR(priv->reset);
+
+	irq = of_irq_get(np, 0);
+	if (irq < 0)
+		return irq;
+
+	ret = devm_request_threaded_irq(dev, irq, an7581_pcm_irq_handler,
+					NULL, IRQF_ONESHOT,
+					dev_name(dev), priv);
+	if (ret)
+		return ret;
+
+	priv->dev = dev;
+	spin_lock_init(&priv->desc_lock);
+
+	ret = snd_pcm_new(card, "AN7581 PCM",
+			  1, /* PCM device 1 (in addition to AFE)) */
+			  1, /* 1 playback substreams */
+			  1, /* 1 capture substream */
+			  &pcm);
+	if (ret)
+		return ret;
+
+	/* Reset the PCM interface */
+	reset_control_assert(priv->reset);
+	usleep_range(5000, 10000);
+	reset_control_deassert(priv->reset);
+	usleep_range(5000, 10000);
+
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK,
+			&an7581_pcm_ops);
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE,
+			&an7581_pcm_ops);
+	pcm->private_data = priv;
+
+	priv->tx_descs = dma_alloc_coherent(priv->dev, sizeof(struct an7581_pcm_desc) *
+					    AN7581_PCM_TX_DESCRIPTORS, &priv->tx_dma,
+					    GFP_KERNEL);
+	if (!priv->tx_descs)
+		return -ENOMEM;
+
+	priv->rx_descs = dma_alloc_coherent(priv->dev, sizeof(struct an7581_pcm_desc) *
+					    AN7581_PCM_RX_DESCRIPTORS, &priv->rx_dma,
+					    GFP_KERNEL);
+	if (!priv->rx_descs)
+		return -ENOMEM;
+
+	snd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV, NULL,
+				       AN7581_PCM_BUFFER_SIZE * AN7581_PCM_TX_DESCRIPTORS,
+				       0);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(an7581_pcm_setup);
-- 
2.50.1

