From 37b0ce896156d89a38e5a26158decafd413e1d85 Mon Sep 17 00:00:00 2001
From: Christian Marangi <ansuelsmth@gmail.com>
Date: Fri, 2 May 2025 01:00:34 +0200
Subject: [PATCH] net: airoha: add support for Airoha AN7583 SoC

Add support for Airoha AN7583 SoC. The same feature of Airoha EN7581 are
supported with the only difference of AN7583 supporting only one PPE and
different reset number for XSI.

To support this, move the PPE num to match data and rework the reset
name logic for XSI.

Signed-off-by: Christian Marangi <ansuelsmth@gmail.com>
---
 drivers/net/ethernet/airoha/airoha_eth.c | 78 ++++++++++++++++++------
 drivers/net/ethernet/airoha/airoha_eth.h |  7 ++-
 drivers/net/ethernet/airoha/airoha_ppe.c |  5 +-
 3 files changed, 70 insertions(+), 20 deletions(-)

diff --git a/drivers/net/ethernet/airoha/airoha_eth.c b/drivers/net/ethernet/airoha/airoha_eth.c
index d748dc6de923..788d75a37ac8 100644
--- a/drivers/net/ethernet/airoha/airoha_eth.c
+++ b/drivers/net/ethernet/airoha/airoha_eth.c
@@ -283,6 +283,7 @@ static int airoha_fe_set_pse_oq_rsv(struct airoha_eth *eth,
 
 static void airoha_fe_pse_ports_init(struct airoha_eth *eth)
 {
+	const struct airoha_eth_match_data *data;
 	const u32 pse_port_num_queues[] = {
 		[FE_PSE_PORT_CDM1] = 6,
 		[FE_PSE_PORT_GDM1] = 6,
@@ -299,9 +300,13 @@ static void airoha_fe_pse_ports_init(struct airoha_eth *eth)
 	u32 all_rsv;
 	int q;
 
+	data = of_device_get_match_data(eth->dev);
+
 	all_rsv = airoha_fe_get_pse_all_rsv(eth);
-	/* hw misses PPE2 oq rsv */
-	all_rsv += PSE_RSV_PAGES * pse_port_num_queues[FE_PSE_PORT_PPE2];
+	if (data->ppe_num > 1) {
+		/* hw misses PPE2 oq rsv */
+		all_rsv += PSE_RSV_PAGES * pse_port_num_queues[FE_PSE_PORT_PPE2];
+	}
 	airoha_fe_set(eth, REG_FE_PSE_BUF_SET, all_rsv);
 
 	/* CMD1 */
@@ -338,13 +343,15 @@ static void airoha_fe_pse_ports_init(struct airoha_eth *eth)
 	for (q = 4; q < pse_port_num_queues[FE_PSE_PORT_CDM4]; q++)
 		airoha_fe_set_pse_oq_rsv(eth, FE_PSE_PORT_CDM4, q,
 					 PSE_QUEUE_RSV_PAGES);
-	/* PPE2 */
-	for (q = 0; q < pse_port_num_queues[FE_PSE_PORT_PPE2]; q++) {
-		if (q < pse_port_num_queues[FE_PSE_PORT_PPE2] / 2)
-			airoha_fe_set_pse_oq_rsv(eth, FE_PSE_PORT_PPE2, q,
-						 PSE_QUEUE_RSV_PAGES);
-		else
-			airoha_fe_set_pse_oq_rsv(eth, FE_PSE_PORT_PPE2, q, 0);
+	if (data->ppe_num > 1) {
+		/* PPE2 */
+		for (q = 0; q < pse_port_num_queues[FE_PSE_PORT_PPE2]; q++) {
+			if (q < pse_port_num_queues[FE_PSE_PORT_PPE2] / 2)
+				airoha_fe_set_pse_oq_rsv(eth, FE_PSE_PORT_PPE2, q,
+							 PSE_QUEUE_RSV_PAGES);
+			else
+				airoha_fe_set_pse_oq_rsv(eth, FE_PSE_PORT_PPE2, q, 0);
+		}
 	}
 	/* GMD4 */
 	for (q = 0; q < pse_port_num_queues[FE_PSE_PORT_GDM4]; q++)
@@ -1293,10 +1300,13 @@ static int airoha_qdma_init(struct platform_device *pdev,
 static int airoha_hw_init(struct platform_device *pdev,
 			  struct airoha_eth *eth)
 {
+	const struct airoha_eth_match_data *data;
 	int err, i;
 
+	data = of_device_get_match_data(eth->dev);
+
 	/* disable xsi */
-	err = reset_control_bulk_assert(ARRAY_SIZE(eth->xsi_rsts),
+	err = reset_control_bulk_assert(data->num_xsi_rsts,
 					eth->xsi_rsts);
 	if (err)
 		return err;
@@ -1300,7 +1305,7 @@ static int airoha_qdma_init(struct platform_device *pdev,
  	if (err)
  		return err;
 
-	err = reset_control_bulk_deassert(ARRAY_SIZE(eth->xsi_rsts), eth->xsi_rsts);
+	err = reset_control_bulk_deassert(data->num_xsi_rsts, eth->xsi_rsts);
 	if (err)
 		return err;
 
@@ -1659,8 +1669,11 @@ static int airoha_dev_init(struct net_device *dev)
 {
 	struct airoha_gdm_port *port = netdev_priv(dev);
 	struct airoha_eth *eth = port->qdma->eth;
+	const struct airoha_eth_match_data *data;
 	u32 pse_port;
 
+	data = of_device_get_match_data(eth->dev);
+
 	airoha_set_macaddr(port, dev->dev_addr);
 
 	switch (port->id) {
@@ -1671,7 +1684,10 @@ static int airoha_dev_init(struct net_device *dev)
 			airhoha_set_gdm2_loopback(port);
 		fallthrough;
 	case 2:
-		pse_port = FE_PSE_PORT_PPE2;
+		if (data->ppe_num > 1)
+			pse_port = FE_PSE_PORT_PPE2;
+		else
+			pse_port = FE_PSE_PORT_PPE1;
 		break;
 	default:
 		pse_port = FE_PSE_PORT_PPE1;
@@ -2550,10 +2566,13 @@ static int airoha_alloc_gdm_port(struct airoha_eth *eth,
 
 static int airoha_probe(struct platform_device *pdev)
 {
+	const struct airoha_eth_match_data *data;
 	struct device_node *np;
 	struct airoha_eth *eth;
 	int i, err;
 
+	data = of_device_get_match_data(&pdev->dev);
+
 	eth = devm_kzalloc(&pdev->dev, sizeof(*eth), GFP_KERNEL);
 	if (!eth)
 		return -ENOMEM;
@@ -2582,12 +2601,10 @@ static int airoha_probe(struct platform_device *pdev)
 		return err;
 	}
 
-	eth->xsi_rsts[0].id = "hsi0-mac";
-	eth->xsi_rsts[1].id = "hsi1-mac";
-	eth->xsi_rsts[2].id = "hsi-mac";
-	eth->xsi_rsts[3].id = "xfp-mac";
+	for (i = 0; i < data->num_xsi_rsts; i++)
+		eth->xsi_rsts[i].id = data->xsi_rsts_names[i];
 	err = devm_reset_control_bulk_get_exclusive(eth->dev,
-						    ARRAY_SIZE(eth->xsi_rsts),
+						    data->num_xsi_rsts,
 						    eth->xsi_rsts);
 	if (err) {
 		dev_err(eth->dev, "failed to get bulk xsi reset lines\n");
@@ -2675,8 +2691,34 @@ static void airoha_remove(struct platform_device *pdev)
 	platform_set_drvdata(pdev, NULL);
 }
 
+static const char * const en7581_xsi_rsts_names[] = {
+	"hsi0-mac",
+	"hsi1-mac",
+	"hsi-mac",
+	"xfp-mac",
+};
+
+static const char * const an7583_xsi_rsts_names[] = {
+	"hsi0-mac",
+	"hsi1-mac",
+	"xfp-mac",
+};
+
+static const struct airoha_eth_match_data en7581_match_data = {
+	.ppe_num = 2,
+	.xsi_rsts_names = en7581_xsi_rsts_names,
+	.num_xsi_rsts = ARRAY_SIZE(en7581_xsi_rsts_names),
+};
+
+static const struct airoha_eth_match_data an7583_match_data = {
+	.ppe_num = 1,
+	.xsi_rsts_names = an7583_xsi_rsts_names,
+	.num_xsi_rsts = ARRAY_SIZE(an7583_xsi_rsts_names),
+};
+
 static const struct of_device_id of_airoha_match[] = {
-	{ .compatible = "airoha,en7581-eth" },
+	{ .compatible = "airoha,en7581-eth", .data = &en7581_match_data },
+	{ .compatible = "airoha,an7583-eth", .data = &an7583_match_data },
 	{ /* sentinel */ }
 };
 MODULE_DEVICE_TABLE(of, of_airoha_match);
diff --git a/drivers/net/ethernet/airoha/airoha_eth.h b/drivers/net/ethernet/airoha/airoha_eth.h
index ec8908f904c6..b02fe26ff48a 100644
--- a/drivers/net/ethernet/airoha/airoha_eth.h
+++ b/drivers/net/ethernet/airoha/airoha_eth.h
@@ -46,7 +46,6 @@
 #define QDMA_METER_IDX(_n)		((_n) & 0xff)
 #define QDMA_METER_GROUP(_n)		(((_n) >> 8) & 0x3)
 
-#define PPE_NUM				2
 #define PPE1_SRAM_NUM_ENTRIES		(8 * 1024)
 #define PPE_SRAM_NUM_ENTRIES		(2 * PPE1_SRAM_NUM_ENTRIES)
 #define PPE_DRAM_NUM_ENTRIES		(16 * 1024)
@@ -506,6 +505,12 @@ struct airoha_eth {
 	struct airoha_gdm_port *ports[AIROHA_MAX_NUM_GDM_PORTS];
 };
 
+struct airoha_eth_match_data {
+	unsigned int ppe_num;
+	int num_xsi_rsts;
+	const char * const *xsi_rsts_names;
+};
+
 u32 airoha_rr(void __iomem *base, u32 offset);
 void airoha_wr(void __iomem *base, u32 offset, u32 val);
 u32 airoha_rmw(void __iomem *base, u32 offset, u32 mask, u32 val);
diff --git a/drivers/net/ethernet/airoha/airoha_ppe.c b/drivers/net/ethernet/airoha/airoha_ppe.c
index f10dab935cab..c5a4f7785d33 100644
--- a/drivers/net/ethernet/airoha/airoha_ppe.c
+++ b/drivers/net/ethernet/airoha/airoha_ppe.c
@@ -39,13 +39,16 @@ static u32 airoha_ppe_get_timestamp(struct airoha_ppe *ppe)
 static void airoha_ppe_hw_init(struct airoha_ppe *ppe)
 {
 	u32 sram_tb_size, sram_num_entries, dram_num_entries;
+	const struct airoha_eth_match_data *data;
 	struct airoha_eth *eth = ppe->eth;
 	int i;
 
+	data = of_device_get_match_data(eth->dev);
+
 	sram_tb_size = PPE_SRAM_NUM_ENTRIES * sizeof(struct airoha_foe_entry);
 	dram_num_entries = PPE_RAM_NUM_ENTRIES_SHIFT(PPE_DRAM_NUM_ENTRIES);
 
-	for (i = 0; i < PPE_NUM; i++) {
+	for (i = 0; i < data->ppe_num; i++) {
 		int p;
 
 		airoha_fe_wr(eth, REG_PPE_TB_BASE(i),
-- 
2.48.1

