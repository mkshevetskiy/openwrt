diff -uNr old/include/net/mac80211.h new/include/net/mac80211.h
--- old/include/net/mac80211.h	2025-03-02 10:38:18.011601000 +0800
+++ new/include/net/mac80211.h	2025-03-02 10:47:04.897499000 +0800
@@ -4887,6 +4887,8 @@
 			    void *type_data);
 	int (*set_attlm)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 			 u16 disabled_links, u16 switch_time, u32 druation);
+	int (*set_qos_map)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+			   struct cfg80211_qos_map *qos_map);	
 	enum ieee80211_neg_ttlm_res
 	(*can_neg_ttlm)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 			struct ieee80211_neg_ttlm *ttlm);
diff -uNr old/net/mac80211/cfg.c new/net/mac80211/cfg.c
--- old/net/mac80211/cfg.c	2025-03-02 10:38:17.901554000 +0800
+++ new/net/mac80211/cfg.c	2025-03-02 10:48:32.385496000 +0800
@@ -4438,8 +4438,10 @@
 				 struct net_device *dev,
 				 struct cfg80211_qos_map *qos_map)
 {
-	struct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);
+	struct ieee80211_sub_if_data *vlan, *sdata = IEEE80211_DEV_TO_SUB_IF(dev);
 	struct mac80211_qos_map *new_qos_map, *old_qos_map;
+	if (!(sdata->flags & IEEE80211_SDATA_IN_DRIVER))
+		return -EIO;
 
 	if (qos_map) {
 		new_qos_map = kzalloc(sizeof(*new_qos_map), GFP_KERNEL);
@@ -4456,7 +4458,13 @@
 	if (old_qos_map)
 		kfree_rcu(old_qos_map, rcu_head);
 
-	return 0;
+	if (sdata->vif.type == NL80211_IFTYPE_AP) {
+		list_for_each_entry(vlan, &sdata->u.ap.vlans, u.vlan.list)
+			rcu_assign_pointer(vlan->qos_map, new_qos_map);
+	}
+	
+	return drv_set_qos_map(sdata->local, sdata);
+
 }
 
 static int ieee80211_set_ap_chanwidth(struct wiphy *wiphy,
diff -uNr old/net/mac80211/chan.c new/net/mac80211/chan.c
--- old/net/mac80211/chan.c	2025-03-02 10:38:17.160562000 +0800
+++ new/net/mac80211/chan.c	2025-03-02 10:49:29.829500000 +0800
@@ -945,6 +945,12 @@
 	}
 
 	ieee80211_check_fast_xmit_iface(sdata);
+	/* FIXME: QoS MAP should be configured for each link (BSS).
+	 * We use assign_link_chanctx for the time being.
+	 * The problematic part is that everytime channel switch happens
+	 * the qos_map would get redundantly configured once.
+	 */
+	drv_set_qos_map(local, sdata);
 
 	return ret;
 }
diff -uNr old/net/mac80211/driver-ops.h new/net/mac80211/driver-ops.h
--- old/net/mac80211/driver-ops.h	2025-03-02 10:38:17.701607000 +0800
+++ new/net/mac80211/driver-ops.h	2025-03-02 10:50:23.128489000 +0800
@@ -1760,4 +1760,27 @@
 
 	return res;
 }
+
+static inline int drv_set_qos_map(struct ieee80211_local *local,
+				  struct ieee80211_sub_if_data *sdata)
+{
+	int ret = -EOPNOTSUPP;
+	struct mac80211_qos_map *qos_map;
+
+	might_sleep();
+	if (!check_sdata_in_driver(sdata))
+		return -EIO;
+
+	qos_map = sdata_dereference(sdata->qos_map, sdata);
+
+	trace_drv_set_qos_map(local, sdata);
+	if (local->ops->set_qos_map)
+		ret = local->ops->set_qos_map(&local->hw, &sdata->vif,
+					      qos_map ? &qos_map->qos_map : NULL);
+	trace_drv_return_int(local, ret);
+
+	return ret;
+}
+
+
 #endif /* __MAC80211_DRIVER_OPS */
diff -uNr old/net/mac80211/iface.c new/net/mac80211/iface.c
--- old/net/mac80211/iface.c	2025-03-02 10:38:17.838551000 +0800
+++ new/net/mac80211/iface.c	2025-03-02 10:51:46.915495000 +0800
@@ -385,8 +385,14 @@
 			 * can only add VLANs to enabled APs
 			 */
 			if (iftype == NL80211_IFTYPE_AP_VLAN &&
-			    nsdata->vif.type == NL80211_IFTYPE_AP)
+			    nsdata->vif.type == NL80211_IFTYPE_AP) {
 				sdata->bss = &nsdata->u.ap;
+				rcu_read_lock();
+				rcu_assign_pointer(sdata->qos_map,
+				rcu_dereference(nsdata->qos_map));
+				rcu_read_unlock();
+			}
+				
 		}
 	}
 
diff -uNr old/net/mac80211/trace.h new/net/mac80211/trace.h
--- old/net/mac80211/trace.h	2025-03-02 10:38:18.023563000 +0800
+++ new/net/mac80211/trace.h	2025-03-02 10:52:34.132478000 +0800
@@ -3179,6 +3179,12 @@
 	)
 );
 
+DEFINE_EVENT(local_sdata_evt, drv_set_qos_map,
+	TP_PROTO(struct ieee80211_local *local,
+		 struct ieee80211_sub_if_data *sdata),
+	TP_ARGS(local, sdata)
+);
+
 	
 #endif /* !__MAC80211_DRIVER_TRACE || TRACE_HEADER_MULTI_READ */
 
