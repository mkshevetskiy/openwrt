diff -uNr old/include/net/cfg80211.h new/include/net/cfg80211.h
--- old/include/net/cfg80211.h	2025-03-03 20:07:38.542237000 +0800
+++ new/include/net/cfg80211.h	2025-03-03 22:42:08.570596000 +0800
@@ -9801,6 +9801,18 @@
 void cfg80211_attlm_notify(struct wireless_dev *wdev, u16 switch_time_tsf_tu,
 			   enum nl80211_attlm_event event, gfp_t gfp);
 /**
+ * cfg80211_tsf_offset_notify - notify about tsf offset
+ * @wdev: the wireless device to receive notification
+ * @link_id: the link ID of the other reported link which would be put in per-sta profile
+ * @tsf_offset: the TSF offset of the reporting links
+ * @len: The len of tsf_offset
+ * @gfp: allocation flags
+ */
+void cfg80211_tsf_offset_notify(struct wireless_dev *wdev, unsigned int link_id,
+				s64 *tsf_offset, size_t len, gfp_t gfp);
+
+
+/**
  * cfg80211_obss_color_collision_notify - notify about bss color collision
  * @dev: network device
  * @color_bitmap: representations of the colors that the local BSS is aware of
diff -uNr old/include/net/mac80211.h new/include/net/mac80211.h
--- old/include/net/mac80211.h	2025-03-03 20:08:17.107239000 +0800
+++ new/include/net/mac80211.h	2025-03-03 22:43:43.892606000 +0800
@@ -7802,6 +7802,16 @@
  */
 unsigned long ieee80211_get_scanning(struct ieee80211_hw *hw);
 /**
+ * ieee80211_tsf_offset_notify - Get tsf offset
+ * @vif: interface to be notified
+ * @tsf_offset: The tsf_offset
+ *
+ */
+void ieee80211_tsf_offset_notify(struct ieee80211_vif *vif, unsigned int link_id,
+				 s64 *tsf_offset, size_t len, gfp_t gfp);
+
+
+/**
  * ieee80211_crit_update_notify - notify mac80211 about the status of a critical update event
  * @vif: &struct ieee80211_vif pointer from the add_interface callback.
  * @link_id: valid link_id during MLO or 0 for non-MLO
diff -uNr old/include/uapi/linux/nl80211.h new/include/uapi/linux/nl80211.h
--- old/include/uapi/linux/nl80211.h	2025-03-03 20:09:52.367223000 +0800
+++ new/include/uapi/linux/nl80211.h	2025-03-03 22:45:53.306611000 +0800
@@ -1592,6 +1592,7 @@
 	NL80211_CMD_ATTLM_EVENT,
 	NL80211_CMD_SET_ATTLM,
 	NL80211_CMD_NOTIFY_CRIT_UPDATE,
+	NL80211_CMD_TSF_OFFSET_EVENT,
 
 	/* used to define NL80211_CMD_MAX below */
 	__NL80211_CMD_AFTER_LAST,
@@ -3459,7 +3460,7 @@
 	NL80211_ATTR_MLO_ATTLM_EVENT,
 	NL80211_ATTR_MLO_ATTLM_SWITCH_TIME_TSF_TU,
 	NL80211_ATTR_CRTI_UPDATE_EVENT,
-
+	NL80211_ATTR_MLO_TSF_OFFSET_VAL,
 	__NL80211_ATTR_AFTER_LAST,
 	NUM_NL80211_ATTR = __NL80211_ATTR_AFTER_LAST,
 	NL80211_ATTR_MAX = __NL80211_ATTR_AFTER_LAST - 1
diff -uNr old/net/mac80211/cfg.c new/net/mac80211/cfg.c
--- old/net/mac80211/cfg.c	2025-03-03 20:11:28.658226000 +0800
+++ new/net/mac80211/cfg.c	2025-03-03 22:47:33.281580000 +0800
@@ -5290,6 +5290,15 @@
 }
 EXPORT_SYMBOL_GPL(ieee80211_attlm_notify);
 
+void ieee80211_tsf_offset_notify(struct ieee80211_vif *vif, unsigned int link_id,
+				 s64 *tsf_offset, size_t len, gfp_t gfp)
+{
+	cfg80211_tsf_offset_notify(ieee80211_vif_to_wdev(vif), link_id,
+				   tsf_offset, len, gfp);
+}
+EXPORT_SYMBOL_GPL(ieee80211_tsf_offset_notify);
+
+
 void ieee80211_links_removed(struct ieee80211_vif *vif, u16 removed_links)
 {
 	struct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);
diff -uNr old/net/wireless/nl80211.c new/net/wireless/nl80211.c
--- old/net/wireless/nl80211.c	2025-03-03 20:12:34.478208000 +0800
+++ new/net/wireless/nl80211.c	2025-03-03 22:50:30.894564000 +0800
@@ -829,6 +829,8 @@
 	[NL80211_ATTR_MLO_ATTLM_SWITCH_TIME] = { .type = NLA_U16 },
 	[NL80211_ATTR_MLO_ATTLM_DURATION] = { .type = NLA_U32 },
 	[NL80211_ATTR_MLO_ATTLM_SWITCH_TIME_TSF_TU] = { .type = NLA_U16 },
+	[NL80211_ATTR_MLO_TSF_OFFSET_VAL] =
+	{ .type = NLA_BINARY, .len = IEEE80211_MLD_MAX_NUM_LINKS * sizeof(s64) },
 	[NL80211_ATTR_BSS_DUMP_INCLUDE_USE_DATA] = { .type = NLA_FLAG },
 	[NL80211_ATTR_MLO_TTLM_DLINK] = NLA_POLICY_EXACT_LEN(sizeof(u16) * 8),
 	[NL80211_ATTR_MLO_TTLM_ULINK] = NLA_POLICY_EXACT_LEN(sizeof(u16) * 8),
@@ -20006,6 +20008,42 @@
 }
 EXPORT_SYMBOL(cfg80211_attlm_notify);
 
+void cfg80211_tsf_offset_notify(struct wireless_dev *wdev, unsigned int link_id,
+				s64 *tsf_offset, size_t len, gfp_t gfp)
+{
+	struct wiphy *wiphy = wdev->wiphy;
+	struct sk_buff *msg;
+	void *hdr;
+
+	msg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);
+	if (!msg)
+		return;
+
+	hdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_TSF_OFFSET_EVENT);
+	if (!hdr) {
+		nlmsg_free(msg);
+		return;
+	}
+
+	if (wdev->valid_links &&
+	    nla_put_u8(msg, NL80211_ATTR_MLO_LINK_ID, link_id))
+		goto nla_put_failure;
+
+	if (nla_put(msg, NL80211_ATTR_MLO_TSF_OFFSET_VAL, len, tsf_offset))
+		goto nla_put_failure;
+
+	genlmsg_end(msg, hdr);
+
+	genlmsg_multicast_netns(&nl80211_fam, wiphy_net(wiphy), msg, 0,
+				NL80211_MCGRP_MLME, gfp);
+	return;
+
+nla_put_failure:
+	nlmsg_free(msg);
+}
+EXPORT_SYMBOL(cfg80211_tsf_offset_notify);
+
+
 void
 nl80211_radar_notify(struct cfg80211_registered_device *rdev,
 		     const struct cfg80211_chan_def *chandef,
