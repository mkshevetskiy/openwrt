diff -uNr old/include/net/cfg80211.h new/include/net/cfg80211.h
--- old/include/net/cfg80211.h	2025-03-04 00:09:21.688301000 +0800
+++ new/include/net/cfg80211.h	2025-03-04 00:15:12.475260000 +0800
@@ -2785,7 +2785,7 @@
 	u32 n_6ghz_params;
 	struct cfg80211_scan_6ghz_params *scan_6ghz_params;
 	s8 tsf_report_link_id;
-
+	u8 scan_band;
 	/* keep last */
 	struct ieee80211_channel *channels[] __counted_by(n_channels);
 };
@@ -5915,7 +5915,7 @@
 
 	int n_radio;
 	const struct wiphy_radio *radio;
-
+	bool dfs_relax;
 	char priv[] __aligned(NETDEV_ALIGN);
 };
 
@@ -6693,7 +6693,8 @@
  * Return: whether or not the wdev may use the channel
  */
 bool cfg80211_wdev_channel_allowed(struct wireless_dev *wdev,
-				   struct ieee80211_channel *chan);
+				    struct ieee80211_channel *chan,
+				    u32 radio_mask);
 
 /**
  * ieee80211_get_response_rate - get basic rate for a given rate
diff -uNr old/net/mac80211/scan.c new/net/mac80211/scan.c
--- old/net/mac80211/scan.c	2025-03-04 00:09:20.861232000 +0800
+++ new/net/mac80211/scan.c	2025-03-04 00:25:58.652165000 +0800
@@ -371,10 +371,9 @@
 	if (ieee80211_hw_check(&local->hw, SINGLE_SCAN_ON_ALL_BANDS)) {
 		local->hw_scan_req->req.n_channels = req->n_channels;
 
-		for (i = 0; i < req->n_channels; i++) {
+		for (i = 0; i < req->n_channels; i++)
 			local->hw_scan_req->req.channels[i] = req->channels[i];
-			bands_used |= BIT(req->channels[i]->band);
-		}
+		bands_used = req->scan_band;
 	} else {
 		do {
 			if (local->hw_scan_band == NUM_NL80211_BANDS)
@@ -384,9 +383,9 @@
 			*n_chans = 0;
 
 			for (i = 0; i < req->n_channels; i++) {
-				if (req->channels[i]->band !=
-				    local->hw_scan_band)
-					continue;
+				if (req->channels[i]->band != local->hw_scan_band ||
+    				!(req->scan_band & BIT(req->channels[i]->band)))
+						continue;
 				local->hw_scan_req->req.channels[(*n_chans)++] =
 							req->channels[i];
 
@@ -571,7 +570,8 @@
 	return 0;
 }
 
-static bool __ieee80211_can_leave_ch(struct ieee80211_sub_if_data *sdata)
+static bool __ieee80211_can_leave_ch(struct ieee80211_sub_if_data *sdata,
+				     struct cfg80211_scan_request *req)
 {
 	struct ieee80211_local *local = sdata->local;
 	struct ieee80211_sub_if_data *sdata_iter;
@@ -582,24 +582,39 @@
 	if (!ieee80211_is_radar_required(local))
 		return true;
 
-	/* FIXME do not check pre-CAC allowed for scan.
-	if (!regulatory_pre_cac_allowed(local->hw.wiphy))
+	if (!local->hw.wiphy->dfs_relax &&
+    !regulatory_pre_cac_allowed(local->hw.wiphy))
+		return false;
+
+	if (!req->scan_band)
 		return false;
-	*/
 
 	list_for_each_entry(sdata_iter, &local->interfaces, list) {
-		for_each_valid_link(&sdata_iter->wdev, link_id)
-			if (sdata_iter->wdev.links[link_id].cac_started)
-				return false;
+		for_each_valid_link(&sdata_iter->wdev, link_id) {
+			struct cfg80211_chan_def *chandef;
+
+			chandef = wdev_chandef(&sdata_iter->wdev, link_id);
+			if (!chandef || !chandef->chan ||
+			    !(req->scan_band & BIT(chandef->chan->band)))
+				continue;
+
+			if (sdata_iter->wdev.links[link_id].cac_started) {
+				if (!ieee80211_vif_is_mld(&sdata->vif))
+					return false;
+
+				/* Just disable the CAC radio for MLD */
+				req->scan_band &= ~BIT(chandef->chan->band);
+			}
+		}
 	}
 
 	return true;
 }
 
 static bool ieee80211_can_scan(struct ieee80211_local *local,
-			       struct ieee80211_sub_if_data *sdata)
+			       struct ieee80211_sub_if_data *sdata,struct cfg80211_scan_request *req)
 {
-	if (!__ieee80211_can_leave_ch(sdata))
+	if (!__ieee80211_can_leave_ch(sdata, req))
 		return false;
 
 	if (!list_empty(&local->roc_list))
@@ -622,6 +637,8 @@
 	if (!ieee80211_can_scan(local,
 				rcu_dereference_protected(
 					local->scan_sdata,
+					lockdep_is_held(&local->hw.wiphy->mtx)),
+					rcu_dereference_protected(local->scan_req,
 					lockdep_is_held(&local->hw.wiphy->mtx))))
 		return;
 
@@ -719,10 +736,10 @@
 	    !(sdata->vif.active_links & BIT(req->tsf_report_link_id)))
 		return -EINVAL;
 
-	if (!__ieee80211_can_leave_ch(sdata))
+	if (!__ieee80211_can_leave_ch(sdata, req))
 		return -EBUSY;
 
-	if (!ieee80211_can_scan(local, sdata)) {
+	if (!ieee80211_can_scan(local, sdata, req)) {
 		/* wait for the work to finish/time out */
 		rcu_assign_pointer(local->scan_req, req);
 		rcu_assign_pointer(local->scan_sdata, sdata);
@@ -735,19 +752,8 @@
 
 		local->hw_scan_ies_bufsize = local->scan_ies_len + req->ie_len;
 
-		if (ieee80211_hw_check(&local->hw, SINGLE_SCAN_ON_ALL_BANDS)) {
-			int i, n_bands = 0;
-			u8 bands_counted = 0;
-
-			for (i = 0; i < req->n_channels; i++) {
-				if (bands_counted & BIT(req->channels[i]->band))
-					continue;
-				bands_counted |= BIT(req->channels[i]->band);
-				n_bands++;
-			}
-
-			local->hw_scan_ies_bufsize *= n_bands;
-		}
+		if (ieee80211_hw_check(&local->hw, SINGLE_SCAN_ON_ALL_BANDS))	
+			local->hw_scan_ies_bufsize *= hweight8(req->scan_band);
 
 		local->hw_scan_req = kmalloc(struct_size(local->hw_scan_req,
 							 req.channels,
@@ -763,7 +769,7 @@
 		 * up but let UBSAN know the boundaries.
 		 */
 		local->hw_scan_req->req.n_channels = req->n_channels;
-
+		local->hw_scan_req->req.scan_band = req->scan_band;
 		ies = (u8 *)local->hw_scan_req +
 			sizeof(*local->hw_scan_req) +
 			req->n_channels * sizeof(req->channels[0]);
@@ -1204,7 +1210,7 @@
 				if (tmp_ch->flags & (IEEE80211_CHAN_NO_IR |
 						     IEEE80211_CHAN_DISABLED) ||
 				    !cfg80211_wdev_channel_allowed(&sdata->wdev,
-								   tmp_ch))
+								  tmp_ch, 0))
 					continue;
 
 				local->int_scan_req->channels[n_ch] = tmp_ch;
@@ -1221,7 +1227,7 @@
 			if (channels[i]->flags & (IEEE80211_CHAN_NO_IR |
 						  IEEE80211_CHAN_DISABLED) ||
 			    !cfg80211_wdev_channel_allowed(&sdata->wdev,
-							   channels[i]))
+							   channels[i], 0))
 				continue;
 
 			local->int_scan_req->channels[n_ch] = channels[i];
diff -uNr old/net/wireless/debugfs.c new/net/wireless/debugfs.c
--- old/net/wireless/debugfs.c	2025-03-04 00:09:20.562240000 +0800
+++ new/net/wireless/debugfs.c	2025-03-04 00:28:13.603150000 +0800
@@ -407,6 +407,58 @@
 DEFINE_DEBUGFS_ATTRIBUTE(dfs_available_reset_ops, NULL,
 			 dfs_available_reset, "0x%08llx\n");
 
+static ssize_t scan_dfs_relax_write(struct file *file,
+				    const char __user *user_buf,
+				    size_t count, loff_t *ppos)
+{
+	struct wiphy *wiphy = file->private_data;
+	char buf[16];
+
+	if (count >= sizeof(buf))
+		return -EINVAL;
+
+	if (copy_from_user(buf, user_buf, count))
+		return -EFAULT;
+
+	if (count && buf[count - 1] == '\n')
+		buf[count - 1] = '\0';
+	else
+		buf[count] = '\0';
+
+	if (kstrtobool(buf, &wiphy->dfs_relax))
+		return -EINVAL;
+
+	return count;
+}
+
+static ssize_t scan_dfs_relax_read(struct file *file, char __user *user_buf,
+				   size_t count, loff_t *ppos)
+{
+	struct wiphy *wiphy = file->private_data;
+	unsigned int r, offset, buf_size = PAGE_SIZE;
+	char *buf;
+
+	buf = kzalloc(buf_size, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	offset = scnprintf(buf, buf_size, "dfs relax: %u\n", wiphy->dfs_relax);
+
+	r = simple_read_from_buffer(user_buf, count, ppos, buf, offset);
+
+	kfree(buf);
+
+	return r;
+}
+
+static const struct file_operations scan_dfs_relax_ops = {
+	.write = scan_dfs_relax_write,
+	.read = scan_dfs_relax_read,
+	.open = simple_open,
+	.llseek = default_llseek,
+};
+
+
 #define DEBUGFS_ADD(name, chmod)						\
 	debugfs_create_file(#name, chmod, phyd, &rdev->wiphy, &name## _ops)
 
@@ -423,6 +475,7 @@
 	DEBUGFS_ADD(dfs_skip_nop, 0600);
 	DEBUGFS_ADD(dfs_skip_cac, 0600);
 	DEBUGFS_ADD(dfs_available_reset, 0600);
+	DEBUGFS_ADD(scan_dfs_relax, 0644);
 }
 
 struct debugfs_read_work {
diff -uNr old/net/wireless/nl80211.c new/net/wireless/nl80211.c
--- old/net/wireless/nl80211.c	2025-03-04 00:09:21.729295000 +0800
+++ new/net/wireless/nl80211.c	2025-03-04 00:35:29.681135000 +0800
@@ -9363,19 +9363,22 @@
 }
 
 static bool cfg80211_off_channel_oper_allowed(struct wireless_dev *wdev,
-					      struct ieee80211_channel *chan)
+					      struct ieee80211_channel *chan,
+							bool dfs_relax)
 {
 	unsigned int link_id;
 	bool all_ok = true;
 
 	lockdep_assert_wiphy(wdev->wiphy);
 
-	if (!cfg80211_wdev_channel_allowed(wdev, chan))
+	if (!cfg80211_wdev_channel_allowed(wdev, chan, 0))
 		return false;
 
 	if (!cfg80211_beaconing_iface_active(wdev))
 		return true;
 
+	if (dfs_relax)	
+		return true;
 	/*
 	 * FIXME: check if we have a free HW resource/link for chan
 	 *
@@ -9592,7 +9595,7 @@
 
 			/* ignore disabled channels */
 			if (chan->flags & IEEE80211_CHAN_DISABLED ||
-			    !cfg80211_wdev_channel_allowed(wdev, chan))
+			    !cfg80211_wdev_channel_allowed(wdev, chan, 0))
 				continue;
 
 			request->channels[i] = chan;
@@ -9615,6 +9618,11 @@
 		}
 	} else {
 		enum nl80211_band band;
+		u32 radio_mask;
+		
+		err = nl80211_parse_vif_radio_mask(info, &radio_mask);
+		if (err < 0)
+			goto out_free;
 
 		/* all channels */
 		for (band = 0; band < NUM_NL80211_BANDS; band++) {
@@ -9628,7 +9636,7 @@
 				chan = &wiphy->bands[band]->channels[j];
 
 				if (chan->flags & IEEE80211_CHAN_DISABLED ||
-				    !cfg80211_wdev_channel_allowed(wdev, chan))
+				    !cfg80211_wdev_channel_allowed(wdev, chan, radio_mask))
 					continue;
 
 				request->channels[i] = chan;
@@ -9646,9 +9654,9 @@
 
 	for (i = 0; i < request->n_channels; i++) {
 		struct ieee80211_channel *chan = request->channels[i];
-
+		request->scan_band |= BIT(chan->band);
 		/* if we can go off-channel to the target channel we're good */
-		if (cfg80211_off_channel_oper_allowed(wdev, chan))
+		if (cfg80211_off_channel_oper_allowed(wdev, chan, wiphy->dfs_relax))
 			continue;
 
 		if (!cfg80211_wdev_on_sub_chan(wdev, chan, true)) {
@@ -12824,7 +12832,10 @@
 	if (err)
 		return err;
 
-	if (!cfg80211_off_channel_oper_allowed(wdev, chandef.chan)) {
+	if (wdev->links[link_id].cac_started)
+		return -EBUSY;
+
+	if (!cfg80211_off_channel_oper_allowed(wdev, chandef.chan, rdev->wiphy.dfs_relax)) {
 		const struct cfg80211_chan_def *oper_chandef, *compat_chandef;
 
 		oper_chandef = wdev_chandef(wdev, link_id);
@@ -13041,7 +13052,7 @@
 		return -EINVAL;
 
 	if (params.offchan &&
-	    !cfg80211_off_channel_oper_allowed(wdev, chandef.chan))
+	   !cfg80211_off_channel_oper_allowed(wdev, chandef.chan, false))
 		return -EBUSY;
 
 	params.link_id = nl80211_link_id_or_invalid(info->attrs);
diff -uNr old/net/wireless/scan.c new/net/wireless/scan.c
--- old/net/wireless/scan.c	2025-03-04 00:09:21.194279000 +0800
+++ new/net/wireless/scan.c	2025-03-04 00:36:43.881128000 +0800
@@ -957,7 +957,7 @@
 			ieee80211_get_channel(&rdev->wiphy, ap->center_freq);
 
 		if (!chan || chan->flags & IEEE80211_CHAN_DISABLED ||
-		    !cfg80211_wdev_channel_allowed(rdev_req->wdev, chan))
+		  	!cfg80211_wdev_channel_allowed(rdev_req->wdev, chan, 0))
 			continue;
 
 		for (i = 0; i < rdev_req->n_channels; i++) {
@@ -3524,7 +3524,7 @@
 			/* ignore disabled channels */
 			chan = &wiphy->bands[band]->channels[j];
 			if (chan->flags & IEEE80211_CHAN_DISABLED ||
-			    !cfg80211_wdev_channel_allowed(creq->wdev, chan))
+			    !cfg80211_wdev_channel_allowed(creq->wdev, chan, 0))
 				continue;
 
 			/* If we have a wireless request structure and the
diff -uNr old/net/wireless/util.c new/net/wireless/util.c
--- old/net/wireless/util.c	2025-03-04 00:09:20.599252000 +0800
+++ new/net/wireless/util.c	2025-03-04 00:38:24.681125000 +0800
@@ -2933,21 +2933,23 @@
 EXPORT_SYMBOL(cfg80211_radio_chandef_valid);
 
 bool cfg80211_wdev_channel_allowed(struct wireless_dev *wdev,
-				   struct ieee80211_channel *chan)
+				   struct ieee80211_channel *chan,u32 radio_mask)
 {
 	struct wiphy *wiphy = wdev->wiphy;
 	const struct wiphy_radio *radio;
 	struct cfg80211_chan_def chandef;
-	u32 radio_mask;
+	u32 mask = radio_mask & wdev->radio_mask;
 	int i;
 
-	radio_mask = wdev->radio_mask;
-	if (!wiphy->n_radio || radio_mask == BIT(wiphy->n_radio) - 1)
+	if (!radio_mask)
+		mask = wdev->radio_mask;
+	
+	if (!wiphy->n_radio || mask == BIT(wiphy->n_radio) - 1)
 		return true;
 
 	cfg80211_chandef_create(&chandef, chan, NL80211_CHAN_HT20);
 	for (i = 0; i < wiphy->n_radio; i++) {
-		if (!(radio_mask & BIT(i)))
+		if (!(mask & BIT(i)))
 			continue;
 
 		radio = &wiphy->radio[i];
